



Off-side rule - Wikipedia



























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact usDonate





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload file





Languages

Language links are at the top of the page.



















Search











Search





























Create account

Log in








Personal tools





 Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1Definition







2Example







3Implementation







4Alternatives







5Productivity







6Languages



Toggle Languages subsection





6.1Programming languages







6.2Other languages









7See also







8References

















Toggle the table of contents







Off-side rule



5 languages




Français한국어日本語粵語中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationCite this pageGet shortened URLDownload QR codeWikidata item





		Print/export
	


Download as PDFPrintable version

























From Wikipedia, the free encyclopedia


Programming language syntax rule that defines code block demarcation via indentation
This article is about the programming language syntax feature. For other uses, see Offside (disambiguation).
This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: "Off-side rule" – news · newspapers · books · scholar · JSTOR (December 2011) (Learn how and when to remove this template message)

The off-side rule describes syntax of a computer programming language that defines the bounds of a code block via indentation.
[1]
[2]
The term was coined by Peter Landin, possibly as a pun on the offside law in association football.
An off-side rule language is contrasted with a free-form language in which indentation has no syntactic meaning, and indentation is strictly a matter of style.
An off-side rule language is also described as having significant indentation.


Definition[edit]
Peter Landin, in his 1966 article "The Next 700 Programming Languages", defined the off-side rule thus: "Any non-whitespace token to the left of the first such token on the previous line is taken to be the start of a new declaration."[3]

Example[edit]
The following is an example of indentation blocks in Python; a popular off-side rule language. 
In Python, the rule is taken to define the boundaries of statements rather than declarations.

def is_even(a: int) -> bool:
    if a % 2 == 0:
        print('Even!')
        return True
    print('Odd!')
    return False

The body of the function starts on line 2 since it is indented one level (4 spaces) more than the previous line. The if clause body starts on line 3 since it is indented an additional level, and ends on line 4 since line 5 is indented a level less, a.k.a. outdented.
The colon (:) at the end of a control statement line is Python syntax; not an aspect of the off-side rule. The rule can be realized without such colon syntax.

Implementation[edit]
The off-side rule can be implemented in the lexical analysis phase, as in Python, where increasing the indenting results in the lexer outputting an INDENT token, and decreasing the indenting results in the lexer outputting a DEDENT token.[4] These tokens correspond to the opening brace { and closing brace } in languages that use braces for blocks, and means that the phrase grammar does not depend on whether braces or indentation are used. This requires that the lexer hold state, namely the current indent level, and thus can detect changes in indentation when this changes, and thus the lexical grammar is not context-free: INDENT and DEDENT depend on the contextual information of the prior indent level.

Alternatives[edit]
The primary alternative to delimiting blocks by indenting, popularized by broad use and influence of the language C, is to ignore whitespace characters and mark blocks explicitly with curly brackets (i.e., { and }) or some other delimiter. While this allows for more formatting freedom – a developer might choose not to indent small pieces of code like the break and continue statements – sloppily indented code might lead the reader astray, such as the goto fail bug.
Lisp and other S-expression-based languages do not differentiate statements from expressions, and parentheses are enough to control the scoping of all statements within the language. As in curly bracket languages, whitespace is mostly ignored by the reader (i.e., the read function). Whitespace is used to separate tokens.[5] The explicit structure of Lisp code allows automatic indenting, to form a visual cue for human readers.
Another alternative is for each block to begin and end with explicit keywords. For example, in ALGOL 60 and its descendant Pascal, blocks start with keyword begin and end with keyword end. In some languages (but not Pascal), this means that newlines are important[citation needed] (unlike in curly brace languages), but the indentation is not. In BASIC and Fortran, blocks begin with the block name (such as IF) and end with the block name prepended with END (e.g., END IF). In Fortran, each and every block can also have its own unique block name, which adds another level of explicitness to lengthy code. ALGOL 68 and the Bourne shell (sh, and bash) are similar, but the end of the block is usually given by the name of the block written backward (e.g., case starts a switch statement and it spans until the matching esac; similarly conditionals if...then...[elif...[else...]]fi or for loops for...do...od in ALGOL68 or for...do...done in bash).
An interesting variant of this occurs in Modula-2, a Pascal-like language which does away with the difference between one and multiline blocks. This allows the block opener ({ or BEGIN) to be skipped for all but the function level block, requiring only a block terminating token (} or END). It also fixes dangling else. Custom is for the end token to be placed on the same indent level as the rest of the block, giving a blockstructure that is very readable.
One advantage to the Fortran approach is that it improves readability of long, nested, or otherwise complex code. A group of outdents or closing brackets alone provides no contextual cues as to which blocks are being closed, necessitating backtracking, and closer scrutiny while debugging. Further, languages that allow a suffix for END-like keywords further improve such cues, such as continue versus continue for x, and  end-loop marker specifying the index variable NEXT I versus NEXT, and  uniquely named loops CYCLE X1 versus CYCLE. However, modern source code editors often provide visual indicators, such as syntax highlighting, and features such as code folding to assist with these drawbacks.

Productivity[edit]
In the language Scala, early versions allowed curly braces only. Scala 3 added an option to use indenting to structure blocks. Designer Martin Odersky said that this was the single most important way Scala 3 improved his own productivity, that it makes programs over 10% shorter and keeps programmers "in the flow", and advises its use.[6]

Languages[edit]
Programming languages[edit]
ABC
Agda
Boo
BuddyScript
Cobra
CoffeeScript
Converge
Curry
Elm
F# (in early versions, when #light is specified; in later versions when #light "off" is not[7])
Genie
GDScript (Godot Engine)
Haskell[8] (only for where, let, do, or case ... of clauses when braces are omitted)
Inform 7
ISWIM, the abstract language that introduced the rule
LiveScript
Miranda
MoonScript[9][10]
Nemerle, optional mode
Nim
occam
PROMAL
Python
Scala, optional mode
Scheme, when using one of several Scheme Requests for Implementations, the latest of which is SRFI 119
Spin
Woma
XL
Other languages[edit]
Haml
Make (build tool: tabs introduce commands in Make rules)
reStructuredText[11]
Sass
Stylus
YAML
Pug (formerly Jade), see Comparison of web template engines
Control flow commands in the RepRapFirmware dialect of GCode[12]
See also[edit]
Python syntax and semantics § Indentation
Prettyprint
References[edit]


^ 
Hutton, G. (December 6, 2012). "Parsing Using Combinators". In Davis, Kei; Hughes, John (eds.). Functional Programming: Proceedings of the 1989 Glasgow Workshop 21–23 August 1989, Fraserburgh, Scotland. Springer Science & Business Media. pp. 362–364. ISBN 9781447131663. Retrieved September 3, 2015.

^ 
Turner, D.A. (August 13, 2013). "Some History of Functional Programming Languages (Invited Talk)". In Loidl, Hans Wolfgang; Peña, Ricardo (eds.). Trends in Functional Programming: 13th International Symposium, TFP 2012, St Andrews, UK, June 12–14, 2012, Revised Selected Papers. Springer. p. 8. ISBN 9783642404474. Retrieved September 3, 2015.

^ Landin, P. J. (March 1966). "The next 700 programming languages" (PDF). Communications of the ACM. 9 (3): 157–166. doi:10.1145/365230.365257. S2CID 13409665.

^ Python Documentation, 2. Lexical analysis: 2.1.8. Indentation

^ "CLHS: Section 2.1.4.7".

^ Odersky, Martin (June 17, 2020). Martin Odersky: A Scala 3 Update (video). YouTube.  Event occurs at 36:35–45:08. Archived from the original on December 21, 2021. Retrieved April 25, 2021.

^ Syme, Don. "Detailed Release Notes for the F# May 2009 CTP Update and Visual Studio 2010 Beta1 releases". Archived from the original on January 21, 2019.

^ The Haskell Report – Layout

^ MoonScript, a language that compiles to Lua

^ MoonScript 0.5.0 – Language Guide

^ reStructuredText Markup Specification – Indentation

^ https://docs.duet3d.com/User_manual/Reference/Gcode_meta_commands


vteTypes of programming languagesParadigm
Actor-based
Array
Aspect-oriented
Class-based
Concatenative
Concurrent
Dataflow
Declarative
Differentiable
Domain-specific
Dynamic
Esoteric
Event-driven
Extensible
Functional
Imperative
Logic
Macro
Metaprogramming
Object-based
Object-oriented
Pipeline
Procedural
Prototype-based
Reflective
Rule-based
Scripting
Stack-oriented
Synchronous
Tactile
Template
Level
Machine
Assembly
Compiled
Interpreted
Low-level
High-level
Very high-level
Generation
First
Second
Third
Fourth
Fifth
Related
Non-English-based
Visual





Retrieved from "https://en.wikipedia.org/w/index.php?title=Off-side_rule&oldid=1206913419"
Category: Programming language topicsHidden categories: Articles with short descriptionShort description is different from WikidataArticles needing additional references from December 2011All articles needing additional referencesUse mdy dates from July 2022All articles with unsourced statementsArticles with unsourced statements from June 2012Articles with example Python (programming language) code






 This page was last edited on 13 February 2024, at 13:08 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License 4.0;
additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view













Toggle limited content width







