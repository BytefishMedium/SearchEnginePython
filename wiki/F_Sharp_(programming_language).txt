



F Sharp (programming language) - Wikipedia




































Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact usDonate





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload file





Languages

Language links are at the top of the page.



















Search











Search





























Create account

Log in








Personal tools





 Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1History



Toggle History subsection





1.1Versions







1.2Language evolution









2Language overview



Toggle Language overview subsection





2.1Functional programming







2.2Imperative programming







2.3Object-oriented programming







2.4Asynchronous programming







2.5Parallel programming







2.6Units of measure







2.7Metaprogramming







2.8Information-rich programming







2.9Agent programming









3Development tools



Toggle Development tools subsection





3.1Comparison of integrated development environments









4Application areas



Toggle Application areas subsection





4.1Web programming







4.2Cross-platform app development







4.3Analytical programming







4.4Scripting









5Open-source community







6Compatibility







7Examples







8See also







9Notes







10References







11External links

















Toggle the table of contents







F Sharp (programming language)



31 languages




العربيةCatalàČeštinaDanskDeutschEspañolفارسیFrançais한국어IdoItalianoעבריתქართულიMagyarമലയാളംBahasa MelayuNederlands日本語Norsk bokmålPolskiPortuguêsРусскийSlovenčinaСрпски / srpskiSuomiSvenskaไทยTürkçeУкраїнська粵語中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationCite this pageGet shortened URLDownload QR codeWikidata item





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia Commons

























From Wikipedia, the free encyclopedia


Microsoft programming language
Not to be confused with F (programming language) or F* (programming language).
The correct title of this article is F#. The substitution of the # is due to technical restrictions.
F#ParadigmMulti-paradigm: functional, imperative, object-oriented, agent-oriented, metaprogramming, reflective, concurrentFamilyMLDesigned byDon Syme, Microsoft ResearchDeveloperMicrosoft, The F# Software FoundationFirst appeared2005; 19 years ago (2005), version 1.0Stable release8.0.0
   / 14 November 2023; 3 months ago (14 November 2023)
Typing disciplineStatic, strong, inferredOSCross-platform: .NET framework, MonoLicenseMIT License[1][2]Filename extensions.fs, .fsi, .fsx, .fsscriptWebsitefsharp.orgInfluenced byC#, Erlang, Haskell,[3] ML, OCaml,[4][5] Python, ScalaInfluencedC#,[6] Elm, F*, LiveScript
 F Sharp Programming at Wikibooks

F# (pronounced F sharp) is a general-purpose, strongly typed, multi-paradigm programming language that encompasses functional, imperative, and object-oriented programming methods. It is most often used as a cross-platform Common Language Infrastructure (CLI) language on .NET, but can also generate JavaScript[7] and graphics processing unit (GPU) code.[8]
F# is developed by the F# Software Foundation,[9] Microsoft and open contributors. An open source, cross-platform compiler for F# is available from the F# Software Foundation.[10] F# is a fully supported language in Visual Studio[11] and JetBrains Rider.[12] Plug-ins supporting F# exist for many widely used editors including Visual Studio Code, Vim, and Emacs.
F# is a member of the ML language family and originated as a .NET Framework implementation of a core of the programming language OCaml.[4][5] It has also been influenced by C#, 
Python, Haskell,[3] Scala and Erlang.


History[edit]
Versions[edit]


Version

Language specification

Date

Platforms

Runtime


F# 1.x



May 2005[13]

Windows

.NET 1.0 - 3.5


F# 2.0

August 2010

April 2010[14]

Linux, macOS, Windows

.NET 2.0 - 4.0, Mono


F# 3.0

November 2012

August 2012[15]

Linux, macOS, Windows;JavaScript,[7] GPU[8]

.NET 2.0 - 4.5, Mono


F# 3.1

November 2013

October 2013[16]

Linux, macOS, Windows;JavaScript,[7] GPU[8]

.NET 2.0 - 4.5, Mono


F# 4.0

January 2016

July 2015[17]






F# 4.1

May 2018

March 2017[18]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET 3.5 - 4.6.2, .NET, Mono


F# 4.5



August 2018[19]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET 4.5 - 4.7.2,[20] .NET Core SDK 2.1.400[21]


F# 4.6



March 2019[22]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET 4.5 - 4.7.2,[23] .NET Core SDK 2.2.300[24]


F# 4.7



September 2019[25]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET 4.5 - 4.8,[26] .NET Core SDK 3.0.100[27]


F# 5.0



November 2020[28]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET SDK 5.0.100[29]


F# 6.0



November 2021[30]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET SDK 6.0.100[31]


F# 7.0



November 2022[32]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET SDK 7.0.100[33]


F# 8.0



November 2023[34]

Linux, macOS, Windows,
JavaScript,[7] GPU[8]


.NET SDK 8.0.100[35]



Language evolution[edit]
F# uses an open development and engineering process. 
The language evolution process is managed by Don Syme from Microsoft Research as the benevolent dictator for life (BDFL) for the language design, together with the F# Software Foundation.
Earlier versions of the F# language were designed by Microsoft and Microsoft Research using a closed development process.
F# was first included in Visual Studio in the  2010 edition, at the same level as  Visual Basic and C# (albeit as an option), and has remained in subsequent editions, thus making the language widely available and well-supported.
F# originates from Microsoft Research, Cambridge, UK. The language was originally designed and implemented by Don Syme,[4] according to whom in the fsharp team, they say the F is for "Fun".[36] 
Andrew Kennedy contributed to the design of units of measure.[4] The Visual F# Tools for Visual Studio are developed by Microsoft.[4] The F# Software Foundation developed the F# open-source compiler and tools, incorporating the open-source compiler implementation provided by the Microsoft Visual F# Tools team.[9]


Summary of versions



Features added


F# 1.0


Functional programming
Discriminated unions
Records
Tuples
Pattern matching
Type abbreviations
Object-oriented programming
Structs
Signature files
Scripting files
Imperative programming
Modules (no functors)
Nested modules
.NET Interoperability


F# 2.0


Active patterns
Units of measure
Sequence expressions
Asynchronous programming
Agent programming
Extension members
Named arguments
Optional arguments
Array slicing
Quotations
Native interoperability
Computation expressions


F# 3.0[37]


Type providers
LINQ query expressions
CLIMutable attribute
Triple-quoted strings
Auto-properties
Provided units-of-measure


F# 3.1[38]


Named union type fields
Extensions to array slicing
Type inference enhancements


F# 4.0[39]


Printf on unitized values
Extension property initializers
Non-null provided types
Primary constructors as functions
Static parameters for provided methods
Printf interpolation
Extended #if grammar
Tailcall attribute
Multiple interface instantiations
Optional type args
Params dictionaries


F# 4.1[40]


Struct tuples which inter-operate with C# tuples
Struct annotations for Records
Struct annotations for Single-case Discriminated Unions
Underscores in numeric literals
Caller info argument attributes
Result type and some basic Result functions
Mutually referential types and modules within the same file
Implicit "Module" syntax on modules with shared name as type
Byref returns, supporting consuming C# ref-returning methods
Error message improvements
Support for 'fixed'


F# 4.5[28]


Versioning alignment of binary, package, and language
Support for 'Span<T>' and related types
Ability to produce 'byref' returns
The 'voidptr' type
The 'inref<'T>' and 'outref<'T>' types to represent readonly and write-only 'byref's
'IsByRefLike' structs
'IsReadOnly' structs
Extension method support for 'byref<'T>'/'inref<'T>'/'outref<'T>'
'match!' keyword in computation expressions
Relaxed upcast with 'yield' in F# seq/list/array expressions
Relaxed indentation with list and array expressions
Enumeration cases emitted as public


F# 4.6


Anonymous record types


F# 4.7[41]


Implicit yields
No more required double underscore
Indentation relaxations for parameters passed to constructors and static methods
'nameof' function
Open static classes


F# 5.0[42]


FSharp.Core now targets netstandard2.0 only
Package references in F# scripts
Support for Jupyter, nteract, and VSCode Notebooks
String Interpolation
Support for nameof
Open Type declarations
Enhanced Slicing
F# quotations improvements
Applicative Computation Expressions
Improved stack traces in F# async and other computation expressions
Improved .NET interop
Improved Map and Set performance in FSharp.Core
Improved compiler performance
Improved compiler analysis for library authors


F# 6.0[43]


Tasks
Simpler indexing
Augments to "active patterns"
Overloaded custom operations in computation expressions
“as” patterns
Indentation syntax revisions
Additional implicit conversions
Additional implicit upcast conversions
Implicit integer conversions
First-class support for .NET-style implicit conversions
Optional warnings for implicit conversions
Formatting for binary numbers
Discards on use bindings
InlineIfLambda optimizer directive
Resumable code
Additional collection functions
Map has Keys and Values
Additional intrinsics for NativePtr
Additional numeric types with unit annotations
Informational warnings for rarely used symbolic operators


F# 7.0[44]


Static abstract members support in interfaces
Making working with SRTPs (statically resolved type parameters) easier
Required properties checking
Init scope and init-only properties
Reference assemblies support
F# self-contained deployments & Native AOT
Added support for N-d arrays up to rank 32.
Result module functions parity with Option.
Fixes in resumable state machines codegen for the tasks builds.
Better codegen for compiler-generated side-effect-free property getters
ARM64 platform-specific compiler and ARM64 target support in F# compiler. Dependency manager #r caching support
Parallel type-checking and project-checking support (experimental, can be enabled via VS setting, or by tooling authors)
Miscellaneous bugfixes and improvements.




F# 8.0[45]


_.Property shorthand for (fun x -> x.Property)
Nested record field copy and update
while! (while bang) feature [46]
Extended string interpolation syntax
Use and compose string literals for printf and related functions
Arithmetic operators in literals
Type constraint intersection syntax
Extended fixed binding
Easier [<Extension>] method definition
Static members in interfaces
Static let in discriminated unions, records, structs, and types without primary constructors
try-with withing seq{}, [], and [||] collection expressions
Recursive calls and yield! within exception handler
Tail call attribute
[<Struct>] unions can now have > 49 cases
Strict indentation rules
New diagnostics from the compiler
Switches for compiler parallelization



Language overview[edit]
Functional programming[edit]
F# is a strongly typed functional-first language with a large number of capabilities that are normally found only in functional programming languages, while supporting object-oriented features available in C#. Together, these features allow F# programs to be written in a completely functional style and also allow functional and object-oriented styles to be mixed.
Examples of functional features are:

Everything is an expression
Type inference (using Hindley–Milner type inference)
Functions as first-class citizens
Anonymous functions with capturing semantics (i.e., closures)
Immutable variables and objects
Lazy evaluation support
Higher-order functions
Nested functions
Currying
Pattern matching
Algebraic data types
Tuples
List comprehension
Monad pattern support (called computation expressions[47])
Tail Call Optimisation[48]
F# is an expression-based language using eager evaluation and also in some instances lazy evaluation. Every statement in F#, 
including if expressions, try expressions and loops, is a composable expression with a static type.[49] Functions and expressions that do not return any value have a return type of unit. F# uses the let keyword for binding values to a name.[49] For example:

let x = 3 + 4

binds the value 7 to the name x.
New types are defined using the type keyword. For functional programming, F# provides tuple, record, discriminated union, list, option, and result types.[49] A tuple represents a set of n values, where n ≥ 0. The value n is called the arity of the tuple. A 3-tuple would be represented as (A, B, C), where A, B, and C are values of possibly different types. A tuple can be used to store values only when the number of values is known at design-time and stays constant during execution.
A record is a type where the data members are named. Here is an example of record definition: 

 type R = 
        { Name : string 
         Age : int }

Records can be created as let r = { Name="AB"; Age=42}. The with keyword is used to create a copy of a record, as in { r with Name="CD"}, which creates a new record by copying r and changing the value of the Name field (assuming the record created in the last example was named r).
A discriminated union type is a type-safe version of C unions. For example,

 type A = 
    | UnionCaseX of string
    | UnionCaseY of int

Values of the union type can correspond to either union case. The types of the values carried by each union case is included in the definition of each case.
The list type is an immutable linked list represented either using a head::tail notation (:: is the cons operator) or a shorthand as [item1; item2; item3]. An empty list is written []. The option type is a discriminated union type with choices Some(x) or None. F# types may be generic, implemented as generic .NET types.
F# supports lambda functions and closures.[49] All functions in F# are first class values and are immutable.[49] Functions can be curried. Being first-class values, functions can be passed as arguments to other functions. Like other functional programming languages, F# allows function composition using the >> and << operators.
F# provides sequence expressions[50] that define a sequence seq { ... }, list [ ... ] or array [| ... |] through code that generates values. For example,

 seq { for b in 0 .. 25 do
           if b < 15 then
               yield b*b }

forms a sequence of squares of numbers from 0 to 14 by filtering out numbers from the range of numbers from 0 to 25. Sequences are generators – values are generated on-demand (i.e., are lazily evaluated) – while lists and arrays are evaluated eagerly.
F# uses pattern matching to bind values to names. Pattern matching is also used when accessing discriminated unions – the union is value matched against pattern rules and a rule is selected when a match succeeds. F# also supports Active Patterns as a form of extensible pattern matching.[51] It is used, for example, when multiple ways of matching on a type exist.[49]
F# supports a general syntax for defining compositional computations called computation expressions. Sequence expressions, asynchronous computations and queries are particular kinds of computation expressions. Computation expressions are an implementation of the monad pattern.[50]

Imperative programming[edit]
F# support for imperative programming includes

for loops
while loops
arrays, created with the [| ... |] syntax
hash table, created with the dict [ ... ] syntax or System.Collections.Generic.Dictionary<_,_> type.
Values and record fields can also be labelled as mutable. For example:

// Define 'x' with initial value '1'
let mutable x = 1
// Change the value of 'x' to '3'
x <- 3

Also, F# supports access to all CLI types and objects such as those defined in the System.Collections.Generic namespace defining imperative data structures.

Object-oriented programming[edit]
Like other Common Language Infrastructure (CLI) languages, F# can use CLI types through object-oriented programming.[49] F# support for object-oriented programming in expressions includes:

Dot-notation, e.g., x.Name
Object expressions, e.g., { new obj() with member x.ToString() = "hello"}
Object construction, e.g., new Form()
Type tests, e.g., x :? string
Type coercions, e.g., x :?> string
Named arguments, e.g., x.Method(someArgument=1)
Named setters, e.g., new Form(Text="Hello")
Optional arguments, e.g., x.Method(OptionalArgument=1)
Support for object-oriented programming in patterns includes

Type tests, e.g., :? string as s
Active patterns, which can be defined over object types[51]
F# object type definitions can be class, struct, interface, enum, or delegate type definitions, corresponding to the definition forms found in C#. For example, here is a class with a constructor taking a name and age, and declaring two properties.

/// A simple object type definition
type Person(name : string, age : int) =
    member x.Name = name
    member x.Age = age

Asynchronous programming[edit]
F# supports asynchronous programming through asynchronous workflows.[52] An asynchronous workflow is defined as a sequence of commands inside an async{ ... }, as in

let asynctask = 
    async { let req = WebRequest.Create(url)
            let! response = req.GetResponseAsync()
            use stream = response.GetResponseStream()
            use streamreader = new System.IO.StreamReader(stream)
            return streamreader.ReadToEnd() }

The let! indicates that the expression on the right (getting the response) should be done asynchronously but the flow should only continue when the result is available. In other words, from the point of view of the code block, it's as if getting the response is a blocking call, whereas from the point of view of the system, the thread won't be blocked and may be used to process other flows until the result needed for this one becomes available.
The async block may be invoked using the Async.RunSynchronously function. Multiple async blocks can be executed in parallel using the Async.Parallel function that takes a list of async objects (in the example, asynctask is an async object) and creates another async object to run the tasks in the lists in parallel. The resultant object is invoked using Async.RunSynchronously.[52]
Inversion of control in F# follows this pattern.[52]
Since version 6.0, F# supports creating, consuming and returning .NET tasks directly. [53]

    open System.Net.Http
    let fetchUrlAsync (url:string) = // string -> Task<string>
        task {
            use client = new HttpClient()
            let! response = client.GetAsync(url) 
            let! content = response.Content.ReadAsStringAsync()
            do! Task.Delay 500
            return content
        }

    // Usage
    let fetchPrint() =
        let task = task {
            let! data = fetchUrlAsync "https://example.com"
            printfn $"{data}"
        } 
        task.Wait()

Parallel programming[edit]
Parallel programming is supported partly through the Async.Parallel, Async.Start and other operations that run asynchronous blocks in parallel.
Parallel programming is also supported through the Array.Parallel functional programming operators in the F# standard library, direct use of the System.Threading.Tasks task programming model, the direct use of .NET thread pool and .NET threads and through dynamic translation of F# code to alternative parallel execution engines such as GPU[8] code.

Units of measure[edit]
The F# type system supports units of measure checking for numbers.[54]
In F#, you can assign units of measure, such as meters or kilograms, to floating point, unsigned integer[55] and signed integer values. This allows the compiler to check that arithmetic involving these values is dimensionally consistent, helping to prevent common programming mistakes by ensuring that, for instance, lengths aren't mistakenly added to times.
The units of measure feature integrates with F# type inference to require minimal type annotations in user code.[56]


[<Measure>] type m                  // meter
[<Measure>] type s                  // second

let distance = 100.0<m>     // float<m>
let time = 5.0<s>           // float<s>
let speed = distance/time   // float<m/s>


[<Measure>] type kg                 // kilogram
[<Measure>] type N = (kg * m)/(s^2) // Newtons
[<Measure>] type Pa = N/(m^2)       // Pascals 

[<Measure>] type days 
let better_age = 3u<days>          // uint<days>

Note: The F# static type checker provides this functionality at compile time, but units are erased from the compiled code. Consequently, it is not possible to determine a value's unit at runtime.

Metaprogramming[edit]
F# allows some forms of syntax customizing via metaprogramming to support embedding custom domain-specific languages within the F# language, particularly through computation expressions.[49]
F# includes a feature for run-time meta-programming called quotations.[57] A quotation expression evaluates to an abstract syntax tree representation of the F# expressions. Similarly, definitions labelled with the [<ReflectedDefinition>] attribute can also be accessed in their quotation form. F# quotations are used for various purposes including to compile F# code into JavaScript[7] and GPU[8] code. (Quotations represent their F# code expressions as data for use by other parts of the program while requiring it to be syntactically correct F# code).

Information-rich programming[edit]
F# 3.0 introduced a form of compile-time meta-programming through statically extensible type generation called F# type providers.[58] F# type providers allow the F# compiler and tools to be extended with components that provide type information to the compiler on-demand at compile time. F# type providers have been used to give strongly typed access to connected information sources in a scalable way, including to the Freebase knowledge graph.[59]
In F# 3.0 the F# quotation and computation expression features are combined to implement LINQ queries.[60] For example:

// Use the OData type provider to create types that can be used to access the Northwind database.
open Microsoft.FSharp.Data.TypeProviders

type Northwind = ODataService<"http://services.odata.org/Northwind/Northwind.svc">
let db = Northwind.GetDataContext()

// A query expression.
let query1 = query { for customer in db.Customers do
                     select customer }

The combination of type providers, queries and strongly typed functional programming is known as information rich programming.[61]

Agent programming[edit]
F# supports a variation of the Actor programming model through the in-memory implementation of lightweight asynchronous agents. For example, the following code defines an agent and posts 2 messages:

    type Message =
        | Enqueue of string
        | Dequeue of AsyncReplyChannel<Option<string>>

    // Provides concurrent access to a list of strings
    let listManager = MailboxProcessor.Start(fun inbox ->
        let rec messageLoop list = async {
            let! msg = inbox.Receive()
            match msg with
                | Enqueue item ->
                    return! messageLoop (item :: list)

                | Dequeue replyChannel ->
                    match list with
                    | [] -> 
                        replyChannel.Reply None
                        return! messageLoop list
                    | head :: tail ->
                        replyChannel.Reply (Some head)
                        return! messageLoop tail
        }

        // Start the loop with an empty list
        messageLoop []
    )

    // Usage 
    async {
        // Enqueue some strings
        listManager.Post(Enqueue "Hello")
        listManager.Post(Enqueue "World")

        // Dequeue and process the strings
        let! str = listManager.PostAndAsyncReply(Dequeue)
        str |> Option.iter (printfn "Dequeued: %s")

    }
    |> Async.Start

Development tools[edit]
Visual Studio, with the Visual F# tools from Microsoft installed, can be used to create, run and debug F# projects. The Visual F# tools include a Visual Studio-hosted read–eval–print loop (REPL) interactive console that can execute F# code as it is written. Visual Studio for Mac also fully supports F# projects.
Visual Studio Code contains full support for F# via the Ionide extension.
F# can be developed with any text editor. Specific support exists in editors such as Emacs.
JetBrains Rider is optimized for the development of F# Code starting with release 2019.1.[62]
LINQPad has supported F# since version 2.x.[whose?]
Comparison of integrated development environments[edit]
This section is an excerpt from Comparison of integrated development environments § F#.[edit]




IDE

License

Windows

Linux

macOS

Developer


Microsoft Visual Studio

Proprietary
Community Edition: Freeware


Yes

No

Yes

Microsoft


Visual Studio Code[63]

source code(MIT License) - binary(Proprietary)

Yes

Yes

Yes

Microsoft


Rider[64]

Proprietary

Yes

Yes

Yes

JetBrains

Application areas[edit]
F# is a general-purpose programming language.

Web programming[edit]
The SAFE Stack is an end-to-end F# stack to develop web applications. It uses ASP.NET Core on the server side and Fable on the client side.[65]
An alternative end-to-end F# option is the WebSharper framework.[66]

Cross-platform app development[edit]
F# can be used together with the Visual Studio Tools for Xamarin to develop apps for iOS and Android. The Fabulous library provides a more comfortable functional interface.

Analytical programming[edit]
Among others, F# is used for quantitative finance programming,[67] energy trading and portfolio optimization,[68] machine learning,[69] business intelligence[70] and social gaming on Facebook.[71]
In the 2010s, F# has been positioned as an optimized alternative to C#. F#'s scripting ability and inter-language compatibility with all Microsoft products have made it popular among developers.[72]

Scripting[edit]
F# can be used as a scripting language, mainly for desktop read–eval–print loop (REPL) scripting.[73]

Open-source community[edit]
The F# open-source community includes the F# Software Foundation[9] and the F# Open Source Group at GitHub.[10] Popular open-source F# projects include:

Fable, an F# to Javascript transpiler based on Babel.
Paket, an alternative package manager for .NET that can still use NuGet repositories, but has centralised version-management.
FAKE, an F# friendly build-system.
Giraffe, a functionally oriented middleware for ASP.NET Core.
Suave, a lightweight web-server and web-development library.
Compatibility[edit]
F# features a legacy "ML compatibility mode" that can directly compile programs written in a large subset of OCaml roughly, with no functors, objects, polymorphic variants, or other additions.

Examples[edit]
A few small samples follow:

// This is a comment for a sample hello world program.
printfn "Hello World!"

A record type definition. Records are immutable by default and are compared by structural equality.

type Person = {
    FirstName: string
    LastName: string
    Age: int
}

// Creating an instance of the record
let person = { FirstName = "John"; LastName = "Doe"; Age = 30 }


A Person class with a constructor taking a name and age and two immutable properties.

/// This is a documentation comment for a type definition.
type Person(name : string, age : int) =
    member x.Name = name
    member x.Age = age
    
/// class instantiation
let mrSmith = Person("Smith", 42)

A simple example that is often used to demonstrate the syntax of functional languages is the factorial function for non-negative 32-bit integers, here shown in F#:

/// Using pattern matching expression
let rec factorial n =
    match n with
    | 0 -> 1
    | _ -> n * factorial (n - 1)

/// For a single-argument functions there is syntactic sugar (pattern matching function):
let rec factorial = function 
    | 0 -> 1 
    | n -> n * factorial (n - 1)
    
/// Using fold and range operator
let factorial n = [1..n] |> Seq.fold (*) 1

Iteration examples:

/// Iteration using a 'for' loop
let printList lst = 
    for x in lst do
        printfn $"{x}" 

/// Iteration using a higher-order function
let printList2 lst = 
    List.iter (printfn "%d") lst

/// Iteration using a recursive function and pattern matching
let rec printList3 lst =
    match lst with
    | [] -> ()
    | h :: t ->
        printfn "%d" h
        printList3 t

Fibonacci examples:

/// Fibonacci Number formula
[<TailCall>]
let fib n =
    let rec g n f0 f1 =
        match n with
        | 0 -> f0
        | 1 -> f1
        | _ -> g (n - 1) f1 (f0 + f1)
    g n 0 1

/// Another approach - a lazy infinite sequence of Fibonacci numbers
let fibSeq = Seq.unfold (fun (a,b) -> Some(a+b, (b, a+b))) (0,1)

// Print even fibs
[1 .. 10]
|> List.map     fib
|> List.filter  (fun n -> (n % 2) = 0)
|> printList

// Same thing, using a list expression
[ for i in 1..10 do
    let r = fib i
    if r % 2 = 0 then yield r ]
|> printList

A sample Windows Forms program:

// Open the Windows Forms library
open System.Windows.Forms

// Create a window and set a few properties
let form = new Form(Visible=true, TopMost=true, Text="Welcome to F#")

// Create a label to show some text in the form
let label =
    let x = 3 + (4 * 5)
    new Label(Text = $"{x}")

// Add the label to the form
form.Controls.Add(label)

// Finally, run the form
[<System.STAThread>]
Application.Run(form)

Asynchronous parallel programming sample (parallel CPU and I/O tasks):

/// A simple prime number detector
let isPrime (n:int) =
   let bound = int (sqrt (float n))
   seq {2 .. bound} |> Seq.forall (fun x -> n % x <> 0)

// We are using async workflows
let primeAsync n =
    async { return (n, isPrime n) }

/// Return primes between m and n using multiple threads
let primes m n =
    seq {m .. n}
        |> Seq.map primeAsync
        |> Async.Parallel
        |> Async.RunSynchronously
        |> Array.filter snd
        |> Array.map fst

// Run a test
primes 1000000 1002000
    |> Array.iter (printfn "%d")

See also[edit]

Free and open-source software portal
OCaml
C#
.NET Framework
Notes[edit]


^ "F# Software Foundation's License". GitHub. 14 October 2021.

^ "Microsoft's F# License". GitHub. 16 October 2021.

^ a b Syme, Granicz & Cisternino (2007:2)

^ a b c d e "F# Historical Acknowledgements". Microsoft.

^ a b Syme, Don (2006). "Leveraging .NET Meta-programming Components from F#". [F#] is rooted in the Core ML design, and in particular has a core language largely compatible with that of OCaml

^ for async

^ a b c d e f g h i j k l The F# Software Foundation. "Using F# for Web Applications". Retrieved 2020-07-30.

^ a b c d e f g h i j k l m The F# Software Foundation. "Using F# for GPU Programming". Archived from the original on 2019-12-25. Retrieved 2019-12-25.

^ a b c The F# Software Foundation. "The F# Software Foundation". Retrieved 2012-11-24.

^ a b The F# Software Foundation. "F# Compiler (open source edition) @ github". Retrieved 2012-11-24.

^ "Develop with Visual F# in Visual Studio". Retrieved 2020-07-30.

^ "F#". Retrieved 2020-07-30.

^ Syme, Don. "F# 1.0.8 released". Microsoft. Retrieved September 7, 2014.

^ Syme, Don. "F# 2.0 released as part of Visual Studio 2010". Microsoft. Retrieved September 7, 2014.

^ Zander, Jason. "Visual Studio 2012 and .NET Framework 4.5 released to the web". Microsoft. Retrieved September 7, 2014.

^ "Visual Studio 2013 released to web". Microsoft. Retrieved September 7, 2014.

^ "Announcing the RTM of Visual F# 4.0". Microsoft. Retrieved September 15, 2015.

^ "Announcing F# 4.1 and the Visual F# Tools for Visual Studio 2017". Retrieved 2017-03-08.

^ "Announcing F# 4.5". Microsoft. 14 August 2018. Retrieved August 14, 2018.

^ "FSharp.Core 4.5.0".

^ "Download .NET Core 2.1 (Linux, macOS, and Windows)". Microsoft. Retrieved May 13, 2021.

^ "Announcing F# 4.6". Microsoft. 29 March 2019. Retrieved March 29, 2019.

^ "FSharp.Core 4.6.0".

^ "Download .NET Core 2.2 (Linux, macOS, and Windows)". Microsoft. Retrieved May 13, 2021.

^ "Announcing F# 4.7". Microsoft. 23 September 2019. Retrieved September 23, 2019.

^ "FSharp.Core 4.7.0".

^ "Download .NET Core 3.0 (Linux, macOS, and Windows)". Microsoft. Retrieved May 13, 2021.

^ a b "Announcing F# 5". November 10, 2020.

^ "Download .NET 5.0 (Linux, macOS, and Windows)". Microsoft. Retrieved May 13, 2021.

^ "F# 6 is officially here!". November 9, 2021.

^ "Download .NET 6.0 (Linux, macOS, and Windows)". Microsoft. Retrieved November 14, 2021.

^ "Announcing F# 7". November 8, 2022.

^ "Download .NET 7.0 (Linux, macOS, and Windows)". Microsoft. Retrieved November 8, 2022.

^ "Announcing F# 8". November 14, 2023.

^ "Download .NET 8.0 (Linux, macOS, and Windows)". Microsoft. Retrieved November 14, 2023.

^ Edwards, Kathryn (23 December 2008). "The A-Z of programming languages: F#". networkworld.com. IDG. Archived from the original on 13 November 2018. Retrieved 8 August 2016.

^ McNamara, Brian. "More About F# 3.0 Language Features". Microsoft. Retrieved September 7, 2014.

^ McNamara, Brian. "Announcing a pre-release of F# 3.1". Microsoft. Retrieved September 7, 2014.

^ "Announcing the RTM of Visual F# 4.0". Retrieved 2017-03-08.

^ "Announcing F# 4.1 and the Visual F# Tools for Visual Studio 2017". Retrieved 2017-03-08.

^ "Announcing F# 4.7". 23 September 2019.

^ "Announcing F# 5". 10 November 2020.

^ "What's new in F# 6 - F# Guide". 10 March 2023.

^ "Announcing F# 7". 8 November 2022.

^ "Announcing F# 8". 14 November 2023.

^ "Simplifying F# computations with the new 'while!' keyword'". 20 September 2023.

^ "F Sharp Programming/Computation Expressions - Wikibooks, open books for an open world". en.wikibooks.org. Retrieved 2022-01-21.

^ kexugit (8 July 2011). "Tail calls in F#". docs.microsoft.com. Retrieved 2022-04-22.

^ a b c d e f g h "F# Language Overview" (PDF). Retrieved 2007-12-14.

^ a b "Some Details on F# Computation Expressions". Retrieved 2007-12-14.

^ a b "Pattern Matching in F# Part 2 : Active Patterns". Archived from the original on 2012-12-09. Retrieved 2012-11-24.

^ a b c "Introducing F# Asynchronous Workflows". Retrieved 2007-12-14.

^ "Task Expressions". 19 April 2022. Retrieved 2023-01-15.

^ "Units of Measure (F#)". Retrieved 2012-11-24.

^ "Extend Units of Measure to Include More Numeric Types". GitHub.

^ "Units of Measure in F#: Part One, Introducing Units". Retrieved 2012-11-24.

^ "Code Quotations (F#)". Retrieved 2012-11-24.

^ "Type Providers". Retrieved 2012-11-24.

^ "New Tech Report from Microsoft Research: Strongly-Typed Language Support for Internet-Scale Information Sources". Retrieved 2012-11-24.

^ "Query Expressions (F#)". Retrieved 2012-11-24.

^ "F# 3.0 – LINQ + Type Providers= Information Rich Programming". Retrieved 2012-11-24.

^ Alexander Kurakin (15 March 2019). "Rider 2019.1 Kicks off its Early Access Program!".

^ "Use F# on Windows | The F# Software Foundation". fsharp.org. Retrieved 2018-08-07.

^ "Features - Rider". JetBrains. Retrieved 2018-08-07.

^ "Fable: JavaScript you can be proud of!". fable.io. Retrieved 2017-12-09.

^ Intellifactory. "WebSharper home". Retrieved 2012-11-24.

^ "Microsoft Case Studies:Microsoft Visual Studio 2012 - Financial Services Firm". Microsoft. Retrieved 2012-11-25.

^ "F# for Energy Trading and Portfolio Optimization". Retrieved 2012-11-25.

^ "Microsoft Case Study: Grange Insurance". Microsoft. Retrieved 2012-11-25.

^ Trelford, Phil (2007). "Learning with F#". Proceedings of the 4th ACM SIGPLAN workshop on Commercial users of functional programming - CUFP '07. pp. 1–2. doi:10.1145/1362702.1362709. ISBN 9781450378444. S2CID 24018363. Retrieved 2012-11-25.

^ "F# Job in Facebook Social Gaming". Retrieved 2012-11-25.

^ "F# Developer Testimonials". Retrieved May 25, 2021.

^ "Scripting in F#". 12 September 2008. Retrieved 2020-01-17.


References[edit]
Syme, Don; Granicz, Adam; Cisternino, Antonio (2007), Expert F#, Apress
Harrop, Jon (2010), Visual F# 2010 for Technical Computing, Flying Frog Consultancy
Pickering, Robert (2007), Foundations of F#, Apress
Smith, Chris (2009), Programming F#, O'Reilly
Petricek, Tomas (2009), Real World Functional Programming With Examples in F# and C#, Manning Publications
Hansen, Michael; Rischel, Hans (2013), Functional Programming Using F#, Cambridge University Press
Astborg, Johan (2013), F# for Quantitative Finance, Packt Publishing
Lundin, Mikael (2015), Testing with F#, Packt Publishing
External links[edit]



Wikibooks has a book on the topic of: F Sharp Programming

Official website The F# Software Foundation
The F# Open Source Group at GitHub
The Visual F# Developer Center Archived 2008-11-19 at the Wayback Machine
Try F#, for learning F# in a web browser
F# Snippets Site
The Visual F# team blog
The original Microsoft Research website for F#
The F# Survival Guide, Dec 2009 (Web-based book)
The F# Language Specification
An introduction to F# programming Archived 2011-07-13 at the Wayback Machine
A tutorial showing the process of reaching a functional design; includes test and parallel coding
vte.NET
.NET strategy
Libraries and frameworks
Implementations
.NET (Core)
.NET Framework
Version history
.NET Compact Framework
.NET Micro Framework
DotGNU
Mono
XNA Framework
Architecture
Common Language Runtime (CLR)
COM Interop
Framework Class Library (FCL)
Components
ADO.NET
Entity Framework
ASP.NET
Web Forms
AJAX
Core
Dynamic Data
MVC
Razor
Avalonia
ClickOnce
Dynamic Language Runtime
Extensible Application Markup Language (XAML)
Language Integrated Query (LINQ)
Managed Extensibility Framework
Microsoft Silverlight
Microsoft XNA
Parallel Extensions
Windows Communication Foundation (WCF)
WCF Data Services
Windows Forms (WinForms)
Windows Identity Foundation (WIF)
Windows Presentation Foundation (WPF)
Windows Workflow Foundation (WF)
.NET Remoting
ToolsObfuscators
Dotfuscator
SmartAssembly
Decompilers
.NET Reflector
dotPeek
Misc
CLR Profiler
ILAsm
.NET Compiler Platform
Native Image Generator (NGen)
XAMLPad
IDEs
Visual Studio
Blend
Express
MonoDevelop
SharpDevelop
Xamarin Studio
Organizations
.NET Foundation
Microsoft
Xamarin

 Category
 List
 Commons

vteCommon Language InfrastructureArchitecture
Application domain
Code Access Security
Common Intermediate Language
instructions
Common Type System
Platform Invocation Services
Virtual Execution System
Components
Assembly
Delegate
Global Assembly Cache
Manifest
Metadata
Standard Libraries
ImplementationsMicrosoft
.NET
.NET Framework
.NET Compact Framework
.NET Micro Framework
Other
Mono
DotGNU
LanguagesMajor languages
C#
Visual Basic
F#
PowerShell
Other
Axum
A#
Boo
Cobra
C++/CLI
IronScheme
IronPython
IronRuby
JScript .NET
J#
Nemerle
Oxygene
Phalanger
Q#
Scala
Small Basic
X#
Comparison
C# and Java
C# and Visual Basic .NET
Java and .NET platforms
Visual Basic and Visual Basic .NET

vteMicrosoft free and open-source software (FOSS)Overview
Microsoft and open source
Shared Source Initiative
SoftwareApplications
3D Movie Maker
Atom
Conference XP
Family.Show
File Manager
Open Live Writer
Microsoft PowerToys
Terminal
Windows Calculator
Windows Console
Windows Package Manager
WorldWide Telescope
XML Notepad
Video games
Allegiance
Programminglanguages
Bosque
C#
Dafny
F#
F*
GW-BASIC
IronPython
IronRuby
Lean
P
Power Fx
PowerShell
Project Verona
Q#
R Open
Small Basic Online
TypeScript
Visual Basic
Frameworks,development tools
.NET
.NET Bio
.NET Framework
.NET Gadgeteer
.NET MAUI
.NET Micro Framework
AirSim
ASP.NET
ASP.NET AJAX
ASP.NET Core
ASP.NET MVC
ASP.NET Razor
ASP.NET Web Forms
Avalonia
Babylon.js
BitFunnel
Blazor
C++/WinRT
CCF
ChakraCore
CLR Profiler
Dapr
DeepSpeed
DiskSpd
Dryad
Dynamic Language Runtime
eBPF on Windows
Electron
Entity Framework
Fluent Design System
Fluid Framework
Infer.NET
LightGBM
Managed Extensibility Framework
Microsoft Automatic Graph Layout
Microsoft C++ Standard Library
Microsoft Cognitive Toolkit
Microsoft Design Language
Microsoft Detours
Microsoft Enterprise Library
Microsoft SEAL
mimalloc
Mixed Reality Toolkit
ML.NET
mod_mono
Mono
MonoDevelop
MSBuild
MsQuic
Neural Network Intelligence
npm
NuGet
OneFuzz
Open Management Infrastructure
Open Neural Network Exchange
Open Service Mesh
Open XML SDK
Orleans
Playwright
ProcDump
ProcMon
Python Tools for Visual Studio
R Tools for Visual Studio
RecursiveExtractor
Roslyn
Sandcastle
SignalR
StyleCop
SVNBridge
T2 Temporal Prover
Text Template Transformation Toolkit
TLA+ Toolbox
U-Prove
vcpkg
Virtual File System for Git
Visual Studio Code
Voldemort
VoTT
Vowpal Wabbit
Windows App SDK
Windows Communication Foundation
Windows Driver Frameworks
KMDF
UMDF
Windows Forms
Windows Presentation Foundation
Windows Template Library
Windows UI Library
WinJS
WinObjC
WiX
XDP for Windows
XSP
xUnit.net
Z3 Theorem Prover
Operating systems
MS-DOS (v1.25 & v2.0)
Barrelfish
SONiC
CBL-Mariner
Other
ChronoZoom
Extensible Storage Engine
FlexWiki
FourQ
Gollum
Project Mu
ReactiveX
SILK
TLAPS
TPM 2.0 Reference Implementation
WikiBhasha
Licenses
Microsoft Public License
Microsoft Reciprocal License
Forges
CodePlex
GitHub
Related
.NET Foundation
F# Software Foundation
Microsoft Open Specification Promise
Open Letter to Hobbyists
Open Source Security Foundation
Outercurve Foundation
 Category
vteMicrosoft Research (MSR)MainprojectsLanguages, compilers
Bartok
Bosque
Cω
F*
Lean
P
Project Verona
Phoenix
Polyphonic C#
SecPAL
Distributed–grid computing
BitVault
Confidential Consortium Framework
DeepSpeed
Orleans
Internet, networking
AjaxView
Avalanche
Conference XP
Gazelle
HoneyMonkey
Penny Black
Wallop
WikiBhasha
Other projects
Automatic Graph Layout
Cognitive Toolkit
Digits
Holoportation
IllumiRoom
Image Composite Editor
Infer.NET
LightGBM
LiveStation
MyLifeBits
Neural Network Intelligence
NodeXL
OneFuzz
PhotoDNA
SEAL
SLAM
T2 Temporal Prover
WorldWide Telescope
Z3 Theorem Prover
Operating systems
Barrelfish
HomeOS
Midori
Singularity
Verve
APIs
Accelerator
Dryad
Joins
mimalloc
SXM
Launched as products
C#
Comic Chat
Detours
F#
Sideshow
PixelSense (TouchLight)
SenseCam
ClearType
Group Shot
Allegiance
TrueSkill
Songsmith
Xbox
Kinect
MSR LabsappliedresearchLive LabsCurrent
Pivot
Seadragon
Deep Zoom
Discontinued
Deepfish
Listas
Live Clipboard
Photosynth
Volta
FUSE Labs
Docs.com
Kodu
Other labs
Academic Search
adCenter Labs
Office Labs
 Category




Retrieved from "https://en.wikipedia.org/w/index.php?title=F_Sharp_(programming_language)&oldid=1200282267"
Categories: .NET programming languagesCross-platform free softwareFunctional languagesMicrosoft free softwareMicrosoft programming languagesMicrosoft ResearchML programming language familyOCaml programming language familyPattern matching programming languagesProgramming languages created in 2005Programming languages supporting units of measureSoftware using the Apache licenseSoftware using the MIT licenseStatically typed programming languagesHidden categories: Articles with short descriptionShort description matches WikidataRestricted titlesAll articles with specifically marked weasel-worded phrasesArticles with specifically marked weasel-worded phrases from May 2022Articles with excerptsWebarchive template wayback links






 This page was last edited on 29 January 2024, at 05:17 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License 4.0;
additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view













Toggle limited content width







