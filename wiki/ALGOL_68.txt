



ALGOL 68 - Wikipedia



































Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact usDonate





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload file





Languages

Language links are at the top of the page.



















Search











Search





























Create account

Log in








Personal tools





 Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1Overview







2History



Toggle History subsection





2.1Origins







2.2Definition process







2.3Publication







2.4Implementations





2.4.1ALGOL 68-R







2.4.2Others









2.5Timeline







2.6The Algorithmic Language ALGOL 68 Reports and Working Group members







2.7Timeline of standardization









3Notable language elements



Toggle Notable language elements subsection





3.1Bold symbols and reserved words







3.2Units: Expressions







3.3mode: Declarations







3.4Coercions: casting





3.4.1Coercion hierarchy with examples









3.5pr & co: Pragmats and Comments







3.6Expressions and compound statements







3.7struct, union & [:]: Structures, unions and arrays







3.8proc: Procedures







3.9op: Operators





3.9.1Array, Procedure, Dereference and coercion operations







3.9.2Monadic operators







3.9.3Dyadic operators with associated priorities







3.9.4Assignation and identity relations, etc.







3.9.5Special characters









3.10transput: Input and output





3.10.1Books, channels and files







3.10.2formatted transput









3.11par: Parallel processing







3.12Miscellaneous









4Examples of use



Toggle Examples of use subsection





4.1Code sample







4.2Operating systems written in ALGOL 68







4.3Applications







4.4Libraries and APIs









5Program representation



Toggle Program representation subsection





5.1Example of different program representations









6Revisions



Toggle Revisions subsection





6.1The language of the unrevised report







6.2Extension proposals from IFIP WG 2.1







6.3True ALGOL 68s specification and implementation timeline







6.4Implementation specific extensions









7Quotes







8See also







9References



Toggle References subsection





9.1Citations







9.2Works cited









10External links

















Toggle the table of contents







ALGOL 68



17 languages




العربيةDeutschفارسیFrançaisIdoമലയാളംNederlandsNorsk bokmålਪੰਜਾਬੀPortuguêsРусскийSlovenčinaТоҷикӣTürkçeTiếng Việt粵語中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationCite this pageGet shortened URLDownload QR codeWikidata item





		Print/export
	


Download as PDFPrintable version

























From Wikipedia, the free encyclopedia


Programming language


ALGOL 68Revised Report on the Algorithmic Language – Algol 68 Edited by: A. van Wijngaarden et al, September 1973[1]ParadigmsMulti-paradigm: concurrent, imperativeFamilyALGOLDesigned byA. van Wijngaarden, B. J. Mailloux, J. E. L. Peck and C. H. A. Koster, et al.First appearedFinal Report: 1968; 56 years ago (1968)r0Stable releaseAlgol 68/RR
   / Revised Report: 1973; 51 years ago (1973)r1
Typing disciplinestatic, strong, safe, structuralScopeLexicalMajor implementationsALGOL 68C, Algol 68 Genie (recent), ALGOL 68-R, ALGOL 68RS, ALGOL 68S, FLACC, Алгол 68 Ленинград/Leningrad Unit, Odra ALGOL 68DialectsALGOL 68/FR (Final Reportr0)Influenced byALGOL 60, ALGOL YInfluencedC,[3][5] C++,[6] Bourne shell, KornShell, Bash, Steelman, Ada, Python,[7] Seed7, Mary, S3


This article contains Unicode 6.0 "Miscellaneous Technical" characters. Without proper rendering support, you may see question marks, boxes, or other symbols instead of something like "₁₀" (Decimal Exponent Symbol U+23E8 TTF).

ALGOL 68 (short for Algorithmic Language 1968) is an imperative programming language that was conceived as a successor to the ALGOL 60 programming language, designed with the goal of a much wider scope of application and more rigorously defined syntax and semantics.
The complexity of the language's definition, which runs to several hundred pages filled with non-standard terminology, made compiler implementation difficult and it was said it had "no implementations and no users". This was only partly true; ALGOL 68 did find use in several niche markets, notably in the United Kingdom where it was popular on International Computers Limited (ICL) machines, and in teaching roles. Outside these fields, use was relatively limited.
Nevertheless, the contributions of ALGOL 68 to the field of computer science have been deep, wide-ranging and enduring, although many of these contributions were only publicly identified when they had reappeared in subsequently developed programming languages. Many languages were developed specifically as a response to the perceived complexity of the language, the most notable being Pascal, or were reimplementations for specific roles, like Ada.
Many languages of the 1970s trace their design specifically to ALGOL 68, selecting some features while abandoning others that were considered too complex or out-of-scope for given roles. Among these is the language C, which was directly influenced by ALGOL 68, especially by its strong typing and structures. Most modern languages trace at least some of their syntax to either C or Pascal, and thus directly or indirectly to ALGOL 68.


Overview[edit]
ALGOL 68 features include expression-based syntax, user-declared types and structures/tagged-unions, a reference model of variables and reference parameters, string, array and matrix slicing, and concurrency.
ALGOL 68 was designed by the International Federation for Information Processing (IFIP) IFIP Working Group 2.1 on Algorithmic Languages and Calculi. On December 20, 1968, the language was formally adopted by the group, and then approved for publication by the General Assembly of IFIP.
ALGOL 68 was defined using a formalism, a two-level formal grammar, invented by Adriaan van Wijngaarden. Van Wijngaarden grammars use a context-free grammar to generate an infinite set of productions that will recognize a particular ALGOL 68 program; notably, they are able to express the kind of requirements that in many other programming language technical standards are labelled semantics, and must be expressed in ambiguity-prone natural language prose, and then implemented in compilers as ad hoc code attached to the formal language parser.



ALGOL 68 was the first (and possibly one of the last) major language for which a full formal definition was made before it was implemented. 


C. H. A. Koster[8]


The main aims and principles of design of ALGOL 68:

Completeness and clarity of description[9]
Orthogonality of design[10]
Security[11]
Efficiency:[12]
Static mode checking
Mode-independent parsing
Independent compiling
Loop optimizing
Representations – in minimal & larger character sets
ALGOL 68 has been criticized, most prominently by some members of its design committee such as C. A. R. Hoare and Edsger Dijkstra, for abandoning the simplicity of ALGOL 60, becoming a vehicle for complex or overly general ideas, and doing little to make the compiler writer's task easier, in contrast to deliberately simple contemporaries (and competitors) such as C, S-algol and Pascal.
In 1970, ALGOL 68-R became the first working compiler for ALGOL 68.
In the 1973 revision, certain features — such as proceduring, gommas[13] and formal bounds — were omitted.[14] C.f. The language of the unrevised report.r0
Though European defence agencies (in Britain Royal Signals and Radar Establishment (RSRE)) promoted the use of ALGOL 68 for its expected security advantages, the American side of the NATO alliance decided to develop a different project, the language Ada, making its use obligatory for US defense contracts.
ALGOL 68 also had a notable influence in the Soviet Union, details of which can be found in Andrey Terekhov's 2014 paper: "ALGOL 68 and Its Impact on the USSR and Russian Programming",[15] and "Алгол 68 и его влияние на программирование в СССР и России".[16]
Steve Bourne, who was on the ALGOL 68 revision committee, took some of its ideas to his Bourne shell (and thereby, to descendant Unix shells such as Bash) and to C (and thereby to descendants such as C++).
The complete history of the project can be found in C. H. Lindsey's A History of ALGOL 68.[17][18]
For a full-length treatment of the language, see "Programming ALGOL 68 Made Easy"[19] by Dr. Sian Mountbatten, or "Learning ALGOL 68 Genie"[20] by Marcel van der Veer which includes the Revised Report.

History[edit]
Origins[edit]
ALGOL 68, as the name implies, is a follow-on to the ALGOL language that was first formalized in 1960. That same year the International Federation for Information Processing (IFIP) formed and started the Working Group on ALGOL, or WG2.1. This group released an updated ALGOL 60 specification in Rome in April 1962. At a follow-up meeting in March 1964, it was agreed that the group should begin work on two follow-on standards, ALGOL X which would be a redefinition of the language with some additions, and an ALGOL Y, which would have the ability to modify its own programs in the style of the language LISP.[21]

Definition process[edit]
The first meeting of the ALGOL X group was held in Princeton University in May 1965. A report of the meeting noted two broadly supported themes, the introduction of strong typing and interest in Euler's concepts of 'trees' or 'lists' for handling collections.[22]
At the second meeting in October in France, three formal proposals were presented, Niklaus Wirth's ALGOL W along with comments about record structures by C.A.R. (Tony) Hoare, a similar language by Gerhard Seegmüller, and a paper by Adriaan van Wijngaarden on "Orthogonal design and description of a formal language". The latter, written in almost indecipherable "W-Grammar", proved to be a decisive shift in the evolution of the language. The meeting closed with an agreement that van Wijngaarden would re-write the Wirth/Hoare submission using his W-Grammar.[22]
This seemingly simple task ultimately proved more difficult than expected, and the follow-up meeting had to be delayed six months. When it met in April 1966 in Kootwijk, van Wijngaarden's draft remained incomplete and Wirth and Hoare presented a version using more traditional descriptions. It was generally agreed that their paper was "the right language in the wrong formalism".[23] As these approaches were explored, it became clear there was a difference in the way parameters were described that would have real-world effects, and while Wirth and Hoare protested that further delays might become endless, the committee decided to wait for van Wijngaarden's version. Wirth then implemented their current definition as ALGOL W.[24]
At the next meeting in Warsaw in October 1966,[25] there was an initial report from the I/O Subcommittee who had met at the Oak Ridge National Laboratory and the University of Illinois but had not yet made much progress. The two proposals from the previous meeting were again explored, and this time a new debate emerged about the use of pointers; ALGOL W used them only to refer to records, while van Wijngaarden's version could point to any object. To add confusion, John McCarthy presented a new proposal for operator overloading and the ability to string together and or constructs, and Klaus Samelson wanted to allow anonymous functions. In the resulting confusion, there was some discussion of abandoning the entire effort.[24] The confusion continued through what was supposed to be the ALGOL Y meeting in Zandvoort in May 1967.[22]

Publication[edit]
A draft report was finally published in February 1968. This was met by "shock, horror and dissent",[22] mostly due to the hundreds of pages of unreadable grammar and odd terminology. Charles H. Lindsey attempted to figure out what "language was hidden inside of it",[26] a process that took six man-weeks of effort. The resulting paper, "ALGOL 68 with fewer tears", was widely circulated. At a wider information processing meeting in Zürich in May 1968, attendees complained that the language was being forced upon them and that IFIP was "the true villain of this unreasonable situation" as the meetings were mostly closed and there was no formal feedback mechanism. Wirth and Peter Naur formally resigned their authorship positions in WG2.1 at that time.[26]
The next WG2.1 meeting took place in Tirrenia in June 1968. It was supposed to discuss the release of compilers and other issues, but instead devolved into a discussion on the language. van Wijngaarden responded by saying (or threatening) that he would release only one more version of the report. By this point Naur, Hoare, and Wirth had left the effort, and several more were threatening to do so.[27] Several more meetings followed, North Berwick in August 1968, Munich in December which produced the release of the official Report in January 1969 but also resulted in a contentious Minority Report being written. Finally, at Banff, Alberta in September 1969, the project was generally considered complete and the discussion was primarily on errata and a greatly expanded Introduction to the Report.[28]
The effort took five years, burned out many of the greatest names in computer science, and on several occasions became deadlocked over issues both in the definition and the group as a whole. Hoare released a "Critique of ALGOL 68" almost immediately,[29] which has been widely referenced in many works. Wirth went on to further develop the ALGOL W concept and released this as Pascal in 1970.

Implementations[edit]
ALGOL 68-R[edit]
The first implementation of the standard, based on the late-1968 draft Report, was introduced by the Royal Radar Establishment in the UK as ALGOL 68-R in July 1970. This was, however, a subset of the full language, and Barry Mailloux, the final editor of the Report, joked that "It is a question of morality.  We have a Bible and you are sinning!"[30] This version nevertheless became very popular on the ICL machines, and became a widely-used language in military coding, especially in the UK.[31]
Among the changes in 68-R was the requirement for all variables to be declared before their first use. This had a significant advantage that it allowed the compiler to be one-pass, as space for the variables in the activation record was set aside before it was used. However, this change also had the side-effect of demanding the PROCs be declared twice, once as a declaration of the types, and then again as the body of code. Another change was to eliminate the assumed VOID mode, an expression that returns no value (named a statement in other languages) and demanding the word VOID be added where it would have been assumed. Further, 68-R eliminated the explicit parallel processing commands based on PAR.[30]

Others[edit]
The first full implementation of the language was introduced in 1974 by CDC Netherlands for the Control Data mainframe series. This saw limited use, mostly teaching in Germany and the Netherlands.[31]
A version similar to 68-R was introduced from Carnegie Mellon University in 1976 as 68S, and was again a one-pass compiler based on various simplifications of the original and intended for use on smaller machines like the DEC PDP-11. It too was used mostly for teaching purposes.[31]
A version for IBM mainframes did not become available until 1978, when one was released from Cambridge University. This was "nearly complete". Lindsey released a version for small machines including the IBM PC in 1984.[31]
Three open source Algol 68 implementations are known:[32]

a68g, GPLv3, written by Marcel van der Veer.
algol68toc, an open-source software port of ALGOL 68RS.
experimental Algol68 frontend for GCC,  written by Jose E. Marchesi.[33]
Timeline[edit]


Year
Event
Contributor


March 1959
ALGOL Bulletin Issue 1 (First)
Peter Naur / ACM


February 1968
Draft Report(DR) Published[34]
IFIP Working Group 2.1


March 1968
Algol 68 Final Reportr0 Presented at Munich Meeting
IFIP Working Group 2.1


June 1968
Meeting in Tirrenia, Italy
IFIP Working Group 2.1


Aug 1968
Meeting in North Berwick, Scotland
IFIP Working Group 2.1


December 1968
ALGOL 68 Final Reportr0 Presented at Munich Meeting
IFIP Working Group 2.1


April 1970
ALGOL 68-R(R) under GEORGE 3 on an ICL 1907F
Royal Signals and Radar Est.


July 1970
ALGOL 68 for the Dartmouth Time Sharing System[35][36]
Sidney Marshall


September 1973
Algol 68 Revised Report[37]r1 Published
IFIP Working Group 2.1


1975
ALGOL 68C(C) – transportable compiler (zcode VM)
S. Bourne, Andrew Birrell, and Michael Guy


June 1975
G. E. Hedrick and Alan Robertson. The Oklahoma State ALGOL 68 Subset Compiler. 1975 International Conference on ALGOL 68.


June 1977
Strathclyde ALGOL 68 conference, Scotland
ACM


May 1978
Proposals for ALGOL H – A Superlanguage of ALGOL 68[38]
A. P. Black, V. J. Rayward-Smith


1984
Full ALGOL 68S(S) compiler for Sun, SPARC, and PCs
C. H. Lindsey et al, Manchester


August 1988
ALGOL Bulletin Issue 52 (last)
Ed. C. H. Lindsey / ACM


May 1997
Algol68 S(S) published on the internet[39]
Charles H. Lindsey


November 2001
Algol 68 Genie(G) published on the internet[40] (GNU GPL open source licensing)
Marcel van der Veer

"A Shorter History of Algol 68"
ALGOL 68 – 3rd generation ALGOL
The Algorithmic Language ALGOL 68 Reports and Working Group members[edit]
March 1968: Draft Report on the Algorithmic Language ALGOL 68[41] – Edited by: Adriaan van Wijngaarden, Barry J. Mailloux, John Peck and Cornelis H. A. Koster.
"Van Wijngaarden once characterized the four authors, somewhat tongue-in-cheek, as: Koster: transputter, Peck: syntaxer, Mailloux: implementer, Van Wijngaarden: party ideologist." – Koster.
October 1968: Penultimate Draft Report on the Algorithmic Language ALGOL 68 — Chapters 1-9[42] Chapters 10-12[43] — Edited by: A. van Wijngaarden, B.J. Mailloux, J. E. L. Peck and C. H. A. Koster.
December 1968: Report on the Algorithmic Language ALGOL 68 — Offprint from Numerische Mathematik, 14, 79-218 (1969); Springer-Verlag.[44] — Edited by: A. van Wijngaarden, B. J. Mailloux, J. E. L. Peck and C. H. A. Koster.
March 1970: Minority report, ALGOL Bulletin AB31.1.1 — signed by Edsger Dijkstra, Fraser Duncan, Jan Garwick, Tony Hoare,  Brian Randell, Gerhard Seegmüller, Wlad Turski, and  Mike Woodger.
September 1973: Revised Report on the Algorithmic Language Algol 68 — Springer-Verlag 1976[45] — Edited by: A. van Wijngaarden, B. Mailloux, J. Peck, K. Koster, Michel Sintzoff, Charles H. Lindsey, Lambert Meertens and Richard G. Fisker.
other WG 2.1 members active in ALGOL 68 design:[18] Friedrich L. Bauer • Hans Bekic • Gerhard Goos • Peter Zilahy Ingerman • Peter Landin • John McCarthy • Jack Merner • Peter Naur • Manfred Paul • Willem van der Poel • Doug Ross • Klaus Samelson • Niklaus Wirth • Nobuo Yoneda.
Timeline of standardization[edit]
1968: On 20 December 1968, the "Final Report" (MR 101) was adopted by the Working Group, then subsequently approved by the General Assembly of UNESCO's IFIP for publication. Translations of the standard were made for Russian, German, French and Bulgarian, and then later Japanese and Chinese.[46] The standard was also made available in Braille.
1984: TC 97 considered ALGOL 68 for standardisation as "New Work Item" TC97/N1642 [2][3]. West Germany, Belgium, Netherlands, USSR and Czechoslovakia willing to participate in preparing the standard but the USSR and Czechoslovakia "were not the right kinds of member of the right ISO committees"[4] and Algol 68's ISO standardisation stalled.[5]
1988: Subsequently ALGOL 68 became one of the GOST standards in Russia.

GOST 27974-88 Programming language ALGOL 68 — Язык программирования АЛГОЛ 68[47]
GOST 27975-88 Programming language ALGOL 68 extended — Язык программирования АЛГОЛ 68 расширенный[48]
Notable language elements[edit]


This article contains Unicode 6.0 "Miscellaneous Technical" characters. Without proper rendering support, you may see question marks, boxes, or other symbols instead of something like "₁₀" (Decimal Exponent Symbol U+23E8 TTF).

Bold symbols and reserved words[edit]
The standard language contains about sixty reserved words, typically bolded in print, and some with "brief symbol" equivalents:

MODE, OP, PRIO, PROC,
FLEX, HEAP, LOC, LONG, REF, SHORT,
BITS, BOOL, BYTES, CHAR, COMPL, INT, REAL, SEMA, STRING, VOID,
CHANNEL, FILE, FORMAT, STRUCT, UNION,
AT "@", EITHERr0, IS ":=:", ISNT  IS NOTr0 ":/=:" ":≠:", OF "→"r0, TRUE, FALSE, EMPTY, NIL "○", SKIP "~",
CO "¢", COMMENT "¢", PR, PRAGMAT,
CASE ~ IN ~ OUSE ~ IN ~ OUT ~ ESAC "( ~ | ~ |: ~ | ~ | ~ )",
FOR ~ FROM ~ TO ~ BY ~ WHILE ~ DO ~ OD,
IF ~ THEN ~ ELIF ~ THEN ~ ELSE ~ FI "( ~ | ~ |: ~ | ~ | ~ )",
PAR BEGIN ~ END "( ~ )", GO TO, GOTO, EXIT "□"r0.

Units: Expressions[edit]
The basic language construct is the unit. A unit may be a formula, an enclosed clause, a routine text or one of several technically needed constructs (assignation, jump, skip, nihil). The technical term enclosed clause unifies some of the inherently bracketing constructs known as block, do statement, switch statement in other contemporary languages. When keywords are used, generally the reversed character sequence of the introducing keyword is used for terminating the enclosure, e.g. ( IF ~ THEN ~ ELSE ~ FI, CASE ~ IN ~ OUT ~ ESAC, FOR ~ WHILE ~ DO ~ OD ). This Guarded Command syntax was reused by Stephen Bourne in the common Unix Bourne shell. An expression may also yield a multiple value, which is constructed from other values by a collateral clause. This construct just looks like the parameter pack of a procedure call.

mode: Declarations[edit]
The basic data types (called modes in Algol 68 parlance) are real, int, compl (complex number), bool, char, bits and bytes. For example:

INT n = 2;
CO n is fixed as a constant of 2. CO
INT m := 3;
CO m is a newly created local variable whose value is initially set to 3. CO
CO    This is short for ref int m = loc int := 3; CO
REAL avogadro = 6.0221415⏨23; CO Avogadro number CO
long long real long long pi = 3.14159 26535 89793 23846 26433 83279 50288 41971 69399 37510;
COMPL square root of minus one = 0 ⊥ 1;

However, the declaration REAL x; is just syntactic sugar for REF REAL x = LOC REAL;. That is, x is really the constant identifier for a reference to a newly generated local REAL variable.
Furthermore, instead of defining both float and double, or int and long and short, etc., ALGOL 68 provides modifiers, so that the presently common double would be written as LONG REAL or LONG LONG REAL instead, for example. The prelude constants max real and min long int are provided to adapt programs to different implementations.
All variables need to be declared, but declaration does not have to precede the first use.
primitive-declarer: INT, REAL, COMPL, COMPLEXG, BOOL, CHAR, STRING, BITS, BYTES, FORMAT, FILE, PIPEG, CHANNEL, SEMA

BITS – a "packed vector" of BOOL.
BYTES – a "packed vector" of CHAR.
STRING – a FLEXible array of CHAR.
SEMA – a SEMAphore which can be initialised with the OPerator LEVEL.
Complex types can be created from simpler ones using various type constructors:

REF mode – a reference to a value of type mode, similar to & in C/C++ and REF in Pascal
STRUCT – used to build structures, like STRUCT in C/C++ and RECORD in Pascal
UNION – used to build unions, like in C/C++ and Pascal
PROC – used to specify procedures, like functions in C/C++ and procedures/functions in Pascal
For some examples, see Comparison of ALGOL 68 and C++.
Other declaration symbols include:  FLEX, HEAP, LOC, REF, LONG, SHORT, EVENTS

FLEX – declare the array to be flexible, i.e. it can grow in length on demand.
HEAP – allocate variable some free space from the global heap.
LOC – allocate variable some free space of the local stack.
LONG – declare an INT, REAL or COMPL to be of a LONGer size.
SHORT – declare an INT, REAL or COMPL to be of a SHORTer size.
A name for a mode (type) can be declared using a MODE declaration,
which is similar to TYPEDEF in C/C++ and TYPE in Pascal:

 INT max=99;
 MODE newmode = [0:9][0:max]STRUCT (
     LONG REAL a, b, c, SHORT INT i, j, k, REF REAL r
 );

This is similar to the following C code:

  const int max=99;
  typedef struct {
      double a, b, c; short i, j, k; float *r;
  } newmode[9+1][max+1];

For ALGOL 68, only the NEWMODE mode-indication appears to the left of the equals symbol, and most notably the construction is made, and can be read, from left to right without regard to priorities. Also, the lower bound of Algol 68 arrays is one by default, but can be any integer from -max int to max int.
Mode declarations allow types to be recursive: defined directly or indirectly in terms of themselves.
This is subject to some restrictions – for instance, these declarations are illegal:

 MODE A = REF A
 MODE A = STRUCT (A a, B b)
 MODE A = PROC (A a) A

while these are valid:

 MODE A = STRUCT (REF A a, B b)
 MODE A = PROC (REF A a) REF A

Coercions: casting[edit]
The coercions produce a coercee from a coercend according to three criteria: the a priori mode of the coercend before the application of any coercion, the a posteriori mode of the coercee required after those coercions, and the syntactic position or "sort" of the coercee. Coercions may be cascaded.
The six possible coercions are termed deproceduring, dereferencing, uniting, widening, rowing, and voiding. Each coercion, except for uniting, prescribes a corresponding dynamic effect on the associated values. Hence, many primitive actions can be programmed implicitly by coercions.
Context strength – allowed coercions:

soft – deproceduring
weak – dereferencing or deproceduring, yielding a name
meek – dereferencing or deproceduring
firm – meek, followed by uniting
strong – firm, followed by widening, rowing or voiding
Coercion hierarchy with examples[edit]
ALGOL 68 has a hierarchy of contexts which determine the kind of coercions available at a particular point in the program. These contexts are:



Context

Context location

Coercions available

Coercion examples in the context


Soft

Weak

Meek

Firm

Strong


Strong

Right hand side of:
Identity-declarations, as "~" in: REAL x = ~
Initialisations, as "~" in: REAL x := ~
Also:

Actual-parameters of calls, as "~" in:PROC: sin(~)
Enclosed clauses of casts, as "~" in: REAL(~)
Units of routine-texts
Statements yielding VOID
All parts (but one) of a balanced clause
One side of an identity relation, as "~" in:  ~ IS ~

 deproc​edur​ing

 All SOFT then weak derefer​encing (deref​erencing or deproc​eduring, yield​ing a name)

All WEAK then derefer​enc​ing (deref​erenc​ing or deproc​edur​ing)

 All MEEK then unit​ing

 All FIRM then widen​ing, rowing or voiding


Widening occurs if there is no loss of precision. For example: An INT will be coerced to a REAL, and a REAL will be coerced to a LONG REAL. But not vice versa.  Examples:

INT to LONG INT
INT to REAL
REAL to COMPL
BITS to []BOOL
BYTES to STRING
A variable can also be coerced (rowed) to an array of length 1.
For example:

INT to [1]INT
REAL to [1]REAL etc.


Firm


Operands of formulas as "~" in:OP: ~ * ~
Parameters of transput calls

Example:
UNION(INT,REAL) var := 1



Meek


Trimscripts (yielding INT)
Enquiries: e.g. as "~" in the following
IF ~ THEN ... FI and 
FROM ~ BY ~ TO ~ WHILE ~ DO ... OD etc

Primaries of calls (e.g. sin in sin(x))

Examples:
REF REF BOOL to BOOL
REF REF REF INT to INT


Weak


Primaries of slices, as in "~" in: ~[1:99]
Secondaries of selections, as "~" in: value OF ~

Examples:
REF BOOL to REF BOOL
REF REF INT to REF INT
REF REF REF REAL to REF REAL
REF REF REF REF STRUCT to REF STRUCT


Soft

The LHS of assignments, as "~" in: ~ := ...

Example:
deproceduring of: PROC REAL random: e.g. random

For more details about Primaries, Secondaries, Tertiary & Quaternaries refer to Operator precedence.

pr & co: Pragmats and Comments[edit]
Pragmats are directives in the program, typically hints to the compiler; in newer languages these are called "pragmas" (no 't'). e.g.

PRAGMAT heap=32 PRAGMAT
PR heap=32 PR

Comments can be inserted in a variety of ways:

¢ The original way of adding your 2 cents worth to a program ¢
COMMENT "bold" comment COMMENT
CO Style i comment CO
# Style ii comment #
£ This is a hash/pound comment for a UK keyboard £

Normally, comments cannot be nested in ALGOL 68. This restriction can be circumvented by using different comment delimiters (e.g. use hash only for temporary code deletions).

Expressions and compound statements[edit]
ALGOL 68 being an expression-oriented programming language, the value returned by an assignment statement is a reference to the destination. Thus, the following is valid ALGOL 68 code:

 REAL half pi, one pi; one pi := 2 * ( half pi := 2 * arc tan(1) )

This notion is present in C and Perl, among others. Note that as in earlier languages such as Algol 60 and FORTRAN, spaces are allowed in identifiers, so that half pi is a single identifier (thus avoiding the underscores versus camel case versus all lower-case issues).
As another example, to express the mathematical idea of a sum of f(i) from i=1 to n, the following ALGOL 68 integer expression suffices:

 (INT sum := 0; FOR i TO n DO sum +:= f(i) OD; sum)

Note that, being an integer expression, the former block of code can be used in any context where an integer value can be used. A block of code returns the value of the last expression it evaluated; this idea is present in Lisp, among other languages.
Compound statements are all terminated by distinctive closing brackets:

IF choice clauses:
 IF condition THEN statements [ ELSE statements ] FI
 "brief" form:  ( condition | statements | statements )

 IF condition1 THEN statements ELIF condition2 THEN statements [ ELSE statements ] FI
 "brief" form:  ( condition1 | statements |: condition2 | statements | statements )

This scheme not only avoids the dangling else problem but also avoids having to use BEGIN and END in embedded statement sequences.

CASE choice clauses:
 CASE switch IN statements, statements,... [ OUT statements ] ESAC
 "brief" form:  ( switch | statements,statements,... | statements )

 CASE switch1 IN statements, statements,... OUSE switch2 IN statements, statements,... [ OUT statements ] ESAC
 "brief" form of CASE statement:  ( switch1 | statements,statements,... |: switch2 | statements,statements,... | statements )

Choice clause example with Brief symbols:

PROC days in month = (INT year, month)INT:
  (month|
    31,
    (year÷×4=0 ∧ year÷×100≠0  ∨  year÷×400=0 | 29 | 28 ),
    31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  );

Choice clause example with Bold symbols:

PROC days in month = (INT year, month)INT:
  CASE month IN
    31,
    IF year MOD 4 EQ 0 AND year MOD 100 NE 0  OR  year MOD 400 EQ 0 THEN 29 ELSE 28 FI,
    31, 30, 31, 30, 31, 31, 30, 31, 30, 31
  ESAC;

Choice clause example mixing Bold and Brief symbols:

PROC days in month = (INT year, month)INT:
  CASE month IN
¢Jan¢ 31,
¢Feb¢ ( year MOD 4 = 0 AND year MOD 100 ≠ 0  OR  year MOD 400 = 0 | 29 | 28 ),
¢Mar¢ 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ¢ to Dec. ¢
  ESAC;

Algol68 allowed the switch to be of either type INT or (uniquely) UNION. The latter allows the enforcing strong typing onto UNION variables. c.f. union below for example.

do loop clause:
 [ FOR index ] [ FROM first ] [ BY increment ] [ TO last ] [ WHILE condition ] DO statements OD
 The minimum form of a "loop clause" is thus: DO statements OD

This was considered the "universal" loop, the full syntax is:

FOR i FROM 1 BY -22 TO -333 WHILE i×i≠4444 DO ~ OD

The construct have several unusual aspects:

only the DO ~ OD portion was compulsory, in which case the loop will iterate indefinitely.
thus the clause TO 100 DO ~ OD, will iterate only 100 times.
the WHILE "syntactic element" allowed a programmer to break from a FOR loop early. e.g.
INT sum sq:=0;
FOR i
WHILE
  print(("So far:",i,newline));
  sum sq≠70↑2
DO
  sum sq+:=i↑2
OD

Subsequent "extensions" to the standard Algol68 allowed the TO syntactic element to be replaced with UPTO and DOWNTO to achieve a small optimisation.  The same compilers also incorporated:

UNTIL(C) – for late loop termination.
FOREACH(S) – for working on arrays in parallel.
Further examples can be found in the code examples below.

struct, union & [:]: Structures, unions and arrays[edit]
ALGOL 68 supports arrays with any number of dimensions, and it allows for the slicing of whole or partial rows or columns.

 MODE VECTOR = [1:3]    REAL;   # vector MODE declaration (typedef)  #
 MODE MATRIX = [1:3,1:3]REAL;   # matrix MODE declaration (typedef)  #
 VECTOR v1  := (1,2,3);         # array variable initially (1,2,3)   #
 []REAL v2   = (4,5,6);         # constant array, type equivalent to VECTOR, bounds are implied  #
 OP + = (VECTOR a,b) VECTOR:    # binary OPerator definition         #
   (VECTOR out; FOR i FROM ⌊a TO ⌈a DO out[i] := a[i]+b[i] OD; out);
 MATRIX m := (v1, v2, v1+v2);
 print ((m[,2:]));              # a slice of the 2nd and 3rd columns #

Matrices can be sliced either way, e.g.:

 REF VECTOR row = m[2,];  # define a REF (pointer) to the 2nd row #
 REF VECTOR col = m[,2];  # define a REF (pointer) to the 2nd column #

ALGOL 68 supports multiple field structures (STRUCT) and united modes. Reference variables may point to any MODE including array slices and structure fields.
For an example of all this, here is the traditional linked list declaration:

 MODE NODE = UNION (VOID, REAL, INT, COMPL, STRING),
      LIST = STRUCT (NODE val, REF LIST next);

Usage example for UNION CASE of NODE:



Algol68r0 as in the 1968 Final Report

Algol68r1 as in the 1973 Revised Report



 NODE n := "1234";
 REAL r; INT i; COMPL c; STRING s
 CASE r,i,c,s::=n IN
   print(("real:", r)),
   print(("int:", i)),
   print(("compl:", c)),
   print(("string:", s))
   OUT print(("?:", n))
 ESAC



 NODE n := "1234";
 # or n := EMPTY; #
  CASE n IN
   (VOID):     print(("void:", "EMPTY")),
   (REAL r):   print(("real:", r)),
   (INT i):    print(("int:", i)),
   (COMPL c):  print(("compl:", c)),
   (STRING s): print(("string:", s))
   OUT         print(("?:", n))
 ESAC



proc: Procedures[edit]
Procedure (PROC) declarations require type specifications for both the parameters and the result (VOID if none):

 PROC max of real = (REAL a, b) REAL:
    IF a > b THEN a ELSE b FI;

or, using the "brief" form of the conditional statement:

 PROC max of real = (REAL a, b) REAL: (a>b | a | b);

The return value of a proc is the value of the last expression evaluated in the procedure. References to procedures (ref proc) are also permitted. Call-by-reference parameters are provided by specifying references (such as ref real) in the formal argument list. The following example defines a procedure that applies a function (specified as a parameter) to each element of an array:

 PROC apply = (REF [] REAL a, PROC (REAL) REAL f):
  
    FOR i FROM LWB a TO UPB a DO a[i] := f(a[i]) OD

This simplicity of code was unachievable in ALGOL 68's predecessor ALGOL 60.

op: Operators[edit]
The programmer may define new operators and both those and the pre-defined ones may be overloaded and their priorities may be changed by the coder. The following example defines operator MAX with both dyadic and monadic versions (scanning across the elements of an array).

 PRIO MAX = 9;
  
 OP MAX = (INT a,b) INT: ( a>b | a | b );
 OP MAX = (REAL a,b) REAL: ( a>b | a | b );
 OP MAX = (COMPL a,b) COMPL: ( ABS a > ABS b | a | b );
  
 OP MAX = ([]REAL a) REAL:
    (REAL out := a[LWB a];
     FOR i FROM LWB a + 1 TO UPB a DO ( a[i]>out | out:=a[i] ) OD;
     out)

Array, Procedure, Dereference and coercion operations[edit]


PRIOrity

Operation r0&r1

+Algol68r0

+Algol68G


Effectively 12(Primary)
dereferencing, deproceduring(~,~), subscripting[~], rowing[~,], slicing[~:~], size denotations LONG & SHORT

proceduring

currying(~,,,), DIAG, TRNSP, ROW, COL


Effectively 11(Secondary)
OF (selection), LOC & HEAP (generators)

→ (selection)

NEW (generators)

These are technically not operators, rather they are considered "units associated with names"

Monadic operators[edit]


PRIOrity(Tertiary)

Algol68 "Worthy characters[6]"r0&r1

+Algol68r0&r1

+Algol68C,G

+Algol68r0


10
NOT ~, UP, DOWN, LWB, UPB,
-, ABS, ARG, BIN, ENTIER, LENG, LEVEL, ODD, REPR, ROUND, SHORTEN


¬, ↑, ↓, ⌊, ⌈

NORM, TRACE, T, DET, INV

LWS, UPS, ⎩, ⎧, BTB, CTB

Dyadic operators with associated priorities[edit]


PRIOrity(Tertiary)

Algol68 "Worthy characters"r0&r1

+Algol68r0&r1

+Algol68C,G

+Algol68r0


9
+*, I
+×, ⊥

!


8
SHL, SHR, **,  UP, DOWN, LWB, UPB
↑, ↓, ⌊, ⌈

××, ^, LWS, UPS, ⎩, ⎧


7
*, /,  %, OVER,  %*, MOD, ELEM
×, ÷, ÷×, ÷*, %×, □

÷:


6
-, +





5
<, LT, <=, LE,  >=, GE, >, GT
≤, ≥




4
EQ =, NE ~= /=
≠, ¬=




3
&, AND
∧

/\


2
OR
∨

\/


1
MINUSAB, PLUSAB, TIMESAB, DIVAB, OVERAB, MODAB, PLUSTO,
-:=, +:=, *:=, /:=, %:=, %*:=, +=:


×:=, ÷:=, ÷×:=,  ÷*:=,  %×:=

MINUS, PLUS, DIV, OVERB, MODB, ÷::=, PRUS

Specific details:

Tertiaries include names NIL and ○.
LWS: In Algol68r0 the operators LWS and ⎩ ... both return TRUE if the lower state of the dimension of an array is fixed.
The UPS and ⎧ operators are similar on the upper state.
The LWB and UPB operators are automatically available on UNIONs of different orders (and MODEs) of arrays. eg. UPB of union([]int, [,]real, flex[,,,]char)
Assignation and identity relations, etc.[edit]
These are technically not operators, rather they are considered "units associated with names"



PRIOrity(Quaternaries)

Algol68 "Worthy characters"r0&r1

+Algol68r0&r1

+Algol68C,G,R

+Algol68r0


Effectively 0
:=, IS :=:, ISNT :/=: :~=:, AT  @, ":", ";"
:≠: :¬=:
:=:=C, =:=R
..=, .=, CT, ::, CTAB, ::=, .., is not, "..", ".,"

Note: Quaternaries include names SKIP and ~.
":=:" (alternatively "IS") tests if two pointers are equal; ":/=:" (alternatively "ISNT") tests if they are unequal.
Why :=: and :/=: are needed: Consider trying to compare two pointer values, such as the following variables, declared as pointers-to-integer:

REF INT ip, jp 
Now consider how to decide whether these two are pointing to the same location, or whether one of them is pointing to NIL. The following expression

ip = jp 
will dereference both pointers down to values of type INT, and compare those, since the "=" operator is defined for INT, but not REF INT. It is not legal to define "=" for operands of type REF INT and INT at the same time, because then calls become ambiguous, due to the implicit coercions that can be applied: should the operands be left as REF INT and that version of the operator called? Or should they be dereferenced further to INT and that version used instead? Therefore the following expression can never be made legal:

ip = NIL 
Hence the need for separate constructs not subject to the normal coercion rules for operands to operators. But there is a gotcha. The following expressions:

ip :=: jp 
ip :=: NIL 
while legal, will probably not do what might be expected. They will always return FALSE, because they are comparing the actual addresses of the variables ip and jp, rather than what they point to. To achieve the right effect, one would have to write

ip :=: REF INT(jp) 
ip :=: REF INT(NIL) 
Special characters[edit]
IBM 2741 keyboard with APL symbols
Most of Algol's "special" characters (⊂, ≡, ␣, ×, ÷, ≤, ≥, ≠, ¬, ⊃, ≡, ∨, ∧, →, ↓, ↑, ⌊, ⌈, ⎩, ⎧, ⊥, ⏨, ¢, ○ and □) can be found on the IBM 2741 keyboard with the APL "golf-ball" print head inserted; these became available in the mid-1960s while ALGOL 68 was being drafted. These characters are also part of the Unicode standard and most of them are available in several popular fonts.

transput: Input and output[edit]
Transput is the term used to refer to ALGOL 68's input and output facilities. It includes pre-defined procedures for unformatted, formatted and binary transput. Files and other transput devices are handled in a consistent and machine-independent manner. The following example prints out some unformatted output to the standard output device:

  print ((newpage, "Title", newline, "Value of i is ",
    i, "and x[i] is ", x[i], newline))

Note the predefined procedures newpage and newline passed as arguments.

Books, channels and files[edit]
The TRANSPUT is considered to be of BOOKS, CHANNELS and FILES:

Books are made up of pages, lines and characters, and may be backed up by files.
A specific book can be located by name with a call to match.
CHANNELs correspond to physical devices.  e.g. card punches and printers.
Three standard channels are distinguished: stand in channel, stand out channel, stand back channel.
A FILE is a means of communicating between a program and a book that has been opened via some channel.
The MOOD of a file may be read, write, char, bin, and opened.
transput procedures include: establish, create, open, associate, lock, close, scratch.
position enquires: char number, line number, page number.
layout routines include:
space, backspace, newline, newpage.
get good line, get good page, get good book, and PROC set=(REF FILE f, INT page,line,char)VOID:
A file has event routines. e.g. on logical file end, on physical file end, on page end, on line end, on format end, on value error, on char error.
formatted transput[edit]
"Formatted transput" in ALGOL 68's transput has its own syntax and patterns (functions), with FORMATs embedded between two $ characters.[49]
Examples:

 printf (($2l"The sum is:"x, g(0)$, m + n)); ¢ prints the same as: ¢
 print ((new line, new line, "The sum is:", space, whole (m + n, 0))

par: Parallel processing[edit]
ALGOL 68 supports programming of parallel processing. Using the keyword PAR, a collateral clause is converted to a parallel clause, where the synchronisation of actions is controlled using semaphores. In A68G the parallel actions are mapped to threads when available on the hosting operating system. In A68S a different paradigm of parallel processing was implemented (see below).

PROC
    eat = VOID: ( muffins-:=1; print(("Yum!",new line))),
    speak = VOID: ( words-:=1; print(("Yak...",new line)));
 
INT muffins := 4, words := 8;
SEMA mouth = LEVEL 1;
 
PAR BEGIN
    WHILE muffins > 0 DO
        DOWN mouth;
        eat;
        UP mouth
    OD,
    WHILE words > 0 DO
        DOWN mouth;
        speak;
        UP mouth
    OD
END

Miscellaneous[edit]
For its technical intricacies, ALGOL 68 needs a cornucopia of methods to deny the existence of something:

SKIP, "~" or "?"C – an undefined value always syntactically valid,
EMPTY – the only value admissible to VOID, needed for selecting VOID in a UNION,
VOID – syntactically like a MODE, but not one,
NIL or "○" – a name not denoting anything, of an unspecified reference mode,
() or specifically [1:0]INT – a vacuum is an empty array (here specifically of MODE []INT).
undefined – a standards reports procedure raising an exception in the runtime system.
ℵ – Used in the standards report to inhibit introspection of certain types. e.g. SEMA

The term NIL IS var always evaluates to TRUE for any variable (but see above for correct use of IS :/=:), whereas it is not known to which value a comparison x < SKIP evaluates for any integer x.
ALGOL 68 leaves intentionally undefined what happens in case of integer overflow, the integer bit representation, and the degree of numerical accuracy for floating point.
Both official reports included some advanced features that were not part of the standard language.  These were indicated with an ℵ and considered effectively private.  Examples include "≮" and "≯" for templates, the  OUTTYPE/INTYPE for crude duck typing, and the STRAIGHTOUT and STRAIGHTIN operators for "straightening" nested arrays and structures

Examples of use[edit]
Code sample[edit]
This sample program implements the Sieve of Eratosthenes to find all the prime numbers that are less than 100. NIL is the ALGOL 68 analogue of the null pointer in other languages. The notation x OF y accesses a member x of a STRUCT y.

BEGIN # Algol-68 prime number sieve, functional style #
  
  PROC error = (STRING s) VOID:
     (print(( newline, " error: ", s, newline)); GOTO stop);
  PROC one to = (INT n) LIST:
     (PROC f = (INT m,n) LIST: (m>n | NIL | cons(m, f(m+1,n))); f(1,n));
  
  MODE LIST = REF NODE;
  MODE NODE = STRUCT (INT h, LIST t);
  PROC cons = (INT n, LIST l) LIST: HEAP NODE := (n,l);
  PROC hd   = (LIST l) INT: ( l IS NIL | error("hd NIL"); SKIP | h OF l );
  PROC tl   = (LIST l) LIST: ( l IS NIL | error("tl NIL"); SKIP | t OF l );
  PROC show = (LIST l) VOID: ( l ISNT NIL | print((" ",whole(hd(l),0))); show(tl(l)));
  
  PROC filter = (PROC (INT) BOOL p, LIST l) LIST:
     IF l IS NIL THEN NIL
     ELIF p(hd(l)) THEN cons(hd(l), filter(p,tl(l)))
     ELSE filter(p, tl(l))
     FI;
  
  PROC sieve = (LIST l) LIST:
     IF l IS NIL THEN NIL
     ELSE
        PROC not multiple = (INT n) BOOL: n MOD hd(l) ~= 0;
        cons(hd(l), sieve( filter( not multiple, tl(l) )))
     FI;
  
  PROC primes = (INT n) LIST: sieve( tl( one to(n) ));
  
  show( primes(100) )
END

Operating systems written in ALGOL 68[edit]
Cambridge CAP computer – All procedures constituting the operating system were written in ALGOL 68C, although several other closely associated protected procedures, such as a paginator, are written in BCPL.[50]
Eldon 3 – Developed at Leeds University for the ICL 1900 was written in ALGOL 68-R.[51]
Flex machine – The hardware was custom and microprogrammable, with an operating system, (modular) compiler, editor, garbage collector and filing system all written in ALGOL 68RS. The command shell Curt[52] was designed to access typed data similar to Algol-68 modes.
VME – S3 was the implementation language of the operating system VME. S3 was based on ALGOL 68 but with data types and operators aligned to those offered by the ICL 2900 Series.
Note: The Soviet Era computers Эльбрус-1 (Elbrus-1) and Эльбрус-2 were created using high-level language Эль-76 (AL-76), rather than the traditional assembly. Эль-76 resembles Algol-68, The main difference is the dynamic binding types in Эль-76 supported at the hardware level. Эль-76 is used for application, job control, system programming.[53]

Applications[edit]
Both ALGOL 68C and ALGOL 68-R are written in ALGOL 68, effectively making ALGOL 68 an application of itself. Other applications include:

ELLA – a hardware description language and support toolset. Developed by the Royal Signals and Radar Establishment during the 1980s and 1990s.
RAF Strike Command System – "... 400K of error-free ALGOL 68-RT code was produced with three man-years of work. ..."[54]
Libraries and APIs[edit]
NAG Numerical Libraries – a software library of numerical analysis routines. Supplied in ALGOL 68 during the 1980s.
TORRIX – a programming system for operations on vectors and matrices over arbitrary fields and of variable size by S. G. van der Meulen and M. Veldhorst.[55]
Program representation[edit]
A feature of ALGOL 68, inherited from the ALGOL tradition, is its different representations. There is a representation language used to describe algorithms in printed work, a strict language (rigorously defined in the Report), and an official reference language intended to be used in compiler input. The examples contain BOLD typeface words, this is the STRICT language. ALGOL 68's reserved words are effectively in a different namespace from identifiers, and spaces are allowed in identifiers, so this next fragment is legal:

 INT a real int = 3 ;

The programmer who writes executable code does not always have an option of BOLD typeface or underlining in the code as this may depend on hardware and cultural issues. Different methods to denote these identifiers have been devised. This is called a stropping regime. For example, all or some of the following may be available programming representations:

 INT a real int = 3; # the STRICT language #
'INT'A REAL INT = 3; # QUOTE stropping style #
.INT A REAL INT = 3; # POINT stropping style #
 INT a real int = 3; # UPPER stropping style #
 int a_real_int = 3; # RES stropping style, there are 61 accepted reserved words #

All implementations must recognize at least POINT, UPPER and RES inside PRAGMAT sections. Of these, POINT and UPPER stropping are quite common, while RES stropping is a contradiction to the specification (as there are no reserved words). QUOTE (single apostrophe quoting) was the original recommendation, while matched apostrophe quoting, common in ALGOL 60, is not used much in ALGOL 68.[56]
The following characters were recommended for portability, and termed "worthy characters" in the Report on the Standard Hardware Representation of Algol 68 Archived 2014-01-02 at the Wayback Machine:

^ Worthy Characters: ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 "#$%'()*+,-./:;<=>@[ ]_|
This reflected a problem in the 1960s where some hardware didn't support lower-case, nor some other non-ASCII characters, indeed in the 1973 report it was written: "Four worthy characters — "|", "_", "[", and "]" — are often coded differently, even at installations which nominally use the same character set."

Base characters: "Worthy characters" are a subset of "base characters".
Example of different program representations[edit]


Representation

Code


Algol68 "strict"as typically published

¢ underline or 
   bold typeface ¢
 MODE XINT = INT;
 XINT sum sq:=0;
 FOR i WHILE
   sum sq≠70×70
 DO
   sum sq+:=i↑2
 OD


Quote stropping(like wikitext)

'pr' quote 'pr'
'mode' 'xint' = 'int';
'xint' sum sq:=0;
'for' i 'while'
  sum sq≠70×70
'do'
  sum sq+:=i↑2
'od'



For a 7-bit character code compiler

.PR UPPER .PR
MODE XINT = INT;
XINT sum sq:=0;
FOR i WHILE
  sum sq/=70*70
DO
  sum sq+:=i**2
OD



For a 6-bit character code compiler

.PR POINT .PR
.MODE .XINT = .INT;
.XINT SUM SQ:=0;
.FOR I .WHILE
  SUM SQ .NE 70*70
.DO
  SUM SQ .PLUSAB I .UP 2
.OD



Algol68 using RES stropping(reserved word)

.PR RES .PR
mode .xint = int;
.xint sum sq:=0;
for i while
  sum sq≠70×70
do
  sum sq+:=i↑2
od


ALGOL 68 allows for every natural language to define its own set of keywords Algol-68. As a result, programmers are able to write programs using keywords from their native language. Below is an example of a simple procedure that calculates "the day following", the code is in two languages: English and German.[citation needed]

 # Next day date - English variant #
 MODE DATE = STRUCT(INT day, STRING month, INT year);
 PROC the day following = (DATE x) DATE:
      IF day OF  x < length of month (month OF x, year OF x)
      THEN (day OF x + 1, month OF x, year OF x)
      ELIF month OF x = "December"
      THEN (1, "January", year OF x + 1)
      ELSE (1, successor of month (month OF x), year OF x)
      FI;

 # Nachfolgetag - Deutsche Variante #
 MENGE DATUM = TUPEL(GANZ tag, WORT monat, GANZ jahr);
 FUNKTION naechster tag nach = (DATUM x) DATUM:
          WENN tag VON x < monatslaenge(monat VON x, jahr VON x)
          DANN (tag VON x + 1, monat VON x, jahr VON x)
          WENNABER monat VON x = "Dezember"
          DANN (1, "Januar", jahr VON x + 1)
          ANSONSTEN (1, nachfolgemonat(monat VON x), jahr VON x)
          ENDEWENN;

Russian/Soviet example:
In English Algol68's case statement reads CASE ~ IN ~ OUT ~ ESAC, in Cyrillic this reads выб ~ в ~ либо ~ быв.

Revisions[edit]
Except where noted (with a superscript), the language described above is that of the "Revised Report(r1)".

The language of the unrevised report[edit]
The original language (As per the "Final Report"r0) differs in syntax of the mode cast, and it had the feature of proceduring, i.e. coercing the value of a term into a procedure which evaluates the term. Proceduring would be intended to make evaluations lazy. The most useful application could have been the short-circuited evaluation of boolean operators. In:

OP ANDF = (BOOL a,PROC BOOL b)BOOL:(a | b | FALSE);
OP ORF = (BOOL a,PROC BOOL b)BOOL:(a | TRUE | b);

b is only evaluated if a is true.
As defined in ALGOL 68, it did not work as expected, for example in the code:

IF FALSE ANDF CO proc bool: CO ( print ("Should not be executed"); TRUE)
THEN ...

against the programmers naïve expectations the print would be executed as it is only the value of the elaborated enclosed-clause after ANDF that was procedured. Textual insertion of the commented-out PROC BOOL: makes it work.
Some implementations emulate the expected behaviour for this special case by extension of the language.
Before revision, the programmer could decide to have the arguments of a procedure evaluated serially instead of collaterally by using semicolons instead of commas (gommas).
For example in:

PROC test = (REAL a; REAL b) :...
...
test (x PLUS 1, x);

The first argument to test is guaranteed to be evaluated before the second, but in the usual:

PROC test = (REAL a, b) :...
...
test (x PLUS 1, x);

then the compiler could evaluate the arguments in whatever order it felt like.

Extension proposals from IFIP WG 2.1[edit]
After the revision of the report, some extensions to the language have been proposed to widen the applicability:

partial parametrisation (aka Currying): creation of functions (with fewer parameters) by specification of some, but not all parameters for a call, e.g. a function logarithm of two parameters, base and argument, could be specialised to natural, binary or decadic log,[57]
module extension: for support of external linkage,  two mechanisms were proposed, bottom-up definition modules, a more powerful version of the facilities from ALGOL 68-R and top-down holes, similar to the ENVIRON and USING clauses from ALGOL 68C[58]
mode parameters: for implementation of limited parametrical polymorphism (most operations on data structures like lists, trees or other data containers can be specified without touching the pay load).[59]
So far, only partial parametrisation has been implemented, in Algol 68 Genie.

True ALGOL 68s specification and implementation timeline[edit]


Name
Year
Purpose
State
Description
Target CPU
Licensing
Implementation language


Generalized ALGOL
1962
Scientific
NL
ALGOL for generalised grammars





ALGOL YY
1966
Draft proposal
Intl
First version of Algol 68
Specification
ACM



ALGOL 68DR
1968
Draft proposal
Intl
IFIP WG 2.1 Draft Report
Specification – March
ACM



ALGOL 68r0
1968
Standard
Intl
IFIP WG 2.1 Final Report
Specification – August
ACM



ALGOL 68-RR
1970
Military
UK

ICL 1900

ALGOL 60


EPOS ALGOLE
1971
Scientific







ALGOL 68RSRS
1972
Military
UK
Portable compiler system
ICL 2900/Series 39, Multics, VMS & C generator (1993)
Crown Copyright
ALGOL 68RS


Algol 68 with areas
1972
Experimental & other
UK
Addition of areas to Algol 68





Mini ALGOL 68
1973
Research
NL
"An interpreter for simple Algol 68 Programs" Archived 2011-07-18 at the Wayback Machine
Portable interpreter
Mathematisch Centrum
ALGOL 60


OREGANO
1973
Research
US
"The importance of implementation models."

UCLA



ALGOL 68CC
1975
Scientific
UK
Cambridge Algol 68
ICL, IBM 360, PDP 10 & Unix, Telefunken, Tesla & Z80 (1980)[60]
Cambridge
ALGOL 68C


ALGOL 68 Revised Reportr1
1975
Standard
Intl
IFIP WG 2.1 Revised Report
Specification
ACM



Algol HH
1975
Experimental & other
UK
Proposed extensions to the mode system of Algol 68
Specification

ALGOL W


Odra Algol 68
1976
practical uses
USSR/Poland

Odra 1204/IL
Soviet
ALGOL 60


Oklahoma ALGOL 68
1976
programming instruction
USA
Oklahoma State University implementation[61]
IBM 1130 and System/370/158
Unknown
ANSI Fortran 66.


Berlin ALGOL 68
1977
Research
DE
"The Berlin ALGOL 68 implementation" &[62]
An Abstract ALGOL 68 Machine – machine independent Compiler
Technical University of Berlin
CDL 2


FLACCF
1977
Multi-purpose
CA
Revised Report complete implementation with debug features
System/370
lease, Chion Corporation
Assembler


ALGOL 68-RTRT
1979
Scientific
UK
Parallel ALGOL 68-R





RS Algolrs
1979
Scientific
UK






ALGOL 68+
1980
Scientific
NL
Proposed superlanguage of ALGOL 68[63]





M-220 ALGOL 68


USSR

M-220
Soviet
EPSILON


Leningrad ALGOL 68L
1980
Telecommunications
USSR
Full language + modules
IBM, DEC, CAMCOH, PS 1001 & PC
Soviet



Interactive ALGOL 68I
1983

UK
Incremental compilation
PC
Noncommercial shareware



ALGOL 68SS
1985
Scientific
Intl
Sun version of ALGOL 68
Sun-3, Sun SPARC (under SunOS 4.1 & Solaris 2), Atari ST (under GEMDOS), Acorn Archimedes (under RISC OS), VAX-11 under Ultrix-32




Algol68toC[64] (ctrans)
1985
Electronics
UK
ctrans from ELLA ALGOL 68RS
Portable C generator 
Open-source software 1995
ALGOL 68RS


MK2 Interactive ALGOL 68
1992

UK
Incremental compilation
PC
Noncommercial shareware[65]



Algol 68 GenieG
2001
Full language
NL
Includes standard collateral clause
Portable interpreter
GPL
C


Algol 68 Genie version 2.0.0
2010
Full language
NL

Portable interpreter; optional compilation of selected units
GPL
C

The S3 language that was used to write the ICL VME operating system and much other system software on the ICL 2900 Series was a direct derivative of Algol 68. However, it omitted many of the more complex features, and replaced the basic modes with a set of data types that mapped directly to the 2900 Series hardware architecture.

Implementation specific extensions[edit]
ALGOL 68R(R) from RRE was the first ALGOL 68 subset implementation, running on the ICL 1900. Based on the original language, the main subset restrictions were definition before use and no parallel processing. This compiler was popular in UK universities in the 1970s, where many computer science students learnt ALGOL 68 as their first programming language; the compiler was renowned for good error messages.
ALGOL 68RS(RS) from RSRE was a portable compiler system written in ALGOL 68RS (bootstrapped from ALGOL 68R), and implemented on a variety of systems including the ICL 2900/Series 39, Multics and DEC VAX/VMS. The language was based on the Revised Report, but with similar subset restrictions to ALGOL 68R. This compiler survives in the form of an Algol68-to-C compiler.
In ALGOL 68S(S) from Carnegie Mellon University the power of parallel processing was improved by adding an orthogonal extension, eventing. Any variable declaration containing keyword EVENT made assignments to this variable eligible for parallel evaluation, i.e. the right hand side was made into a procedure which was moved to one of the processors of the C.mmp multiprocessor system. Accesses to such variables were delayed after termination of the assignment.
Cambridge ALGOL 68C(C) was a portable compiler that implemented a subset of ALGOL 68, restricting operator definitions and omitting garbage collection, flexible rows and formatted transput.
Algol 68 Genie(G) by M. van der Veer is an ALGOL 68 implementation for today's computers and operating systems.
"Despite good intentions, a programmer may violate portability by inadvertently employing a local extension.  To guard against this, each implementation should provide a PORTCHECK pragmat option.  While this option is in force, the compiler prints a message for each construct that it recognizes as violating some portability constraint."[66]

Quotes[edit]
... The scheme of type composition adopted by C owes considerable debt to Algol 68, although it did not, perhaps, emerge in a form that Algol's adherents would approve of. The central notion I captured from Algol was a type structure based on atomic types (including structures), composed into arrays, pointers (references), and functions (procedures). Algol 68's concept of unions and casts also had an influence that appeared later. Dennis Ritchie Apr 1993.[2]
... C does not descend from Algol 68 is true, yet there was influence, much of it so subtle that it is hard to recover even when I think hard. In particular, the union type (a late addition to C) does owe to A68, not in any details, but in the idea of having such a type at all. More deeply, the type structure in general and even, in some strange way, the declaration syntax (the type-constructor part) was inspired by A68. And yes, of course, "long". Dennis Ritchie, 18 June 1988[4]
"Congratulations, your Master has done it" – Niklaus Wirth[67]
The more I see of it, the more unhappy I become – E. W. Dijkstra, 1968[68]
[...] it was said that A68's popularity was inversely proportional to [...] the distance from Amsterdam – Guido van Rossum[69]
[...] The best we could do was to send with it a minority report, stating our considered view that, "... as a tool for the reliable creation of sophisticated programs, the language was a failure." [...]  – C. A. R. Hoare in his Oct 1980 Turing Award Lecture[70]
"[...] More than ever it will be required from an adequate programming tool that it assists, by structure, the programmer in the most difficult aspects of his job, viz. in the reliable creation of sophisticated programs. In this respect we fail to see how the language proposed here  is a significant step forward: on the contrary, we feel that its implicit view of the programmer's task is very much the same as, say, ten years ago. This forces upon us the conclusion that, regarded as a programming tool, the language must be regarded as obsolete. [...]" 1968 Working Group minority report on 23 December 1968.[71]
See also[edit]

ALGOL 60
ALGOL Y
ALGOL N
ALGOL 68C
C (programming language)
C++
Comparison of ALGOL 68 and C++
Bourne shell
Bash (Unix shell)
Steelman language requirements
Ada (programming language)
Python (programming language)

References[edit]
Citations[edit]


^ van Wijngaarden, Adriaan; Mailloux, Barry James; Peck, John Edward Lancelot; Koster, Cornelis Hermanus Antonius; Sintzoff, Michel [in French]; Lindsey, Charles Hodgson; Meertens, Lambert Guillaume Louis Théodore; Fisker, Richard G., eds. (1976). Revised Report on the Algorithmic Language ALGOL 68 (PDF). Springer-Verlag. ISBN 978-0-387-07592-1. OCLC 1991170. Archived (PDF) from the original on 2019-04-19. Retrieved 2019-05-11.

^ a b Dennis Ritchie (April 1993). "The Development of the C Language" (PDF). Archived from the original (PDF) on 2005-11-06. Retrieved 2007-04-26.

^ Influence on C: types, structures, arrays, pointers and procedures – Dennis Ritchie[2]

^ a b Dennis Ritchie (June 1988). "C and Algol 68". Retrieved 2006-09-15.

^ Influence on C: union, structure, syntax and long precision – Dennis Ritchie[4]

^ "A History of C++: 1979−1991" (PDF). March 1993. Page 12, 2nd paragraph: Algol68 [gave] operator overloading(§3.3.3), references (§3.3.4), and the ability to declare variables anywhere in a block (§3.3.1). Retrieved 2008-05-06.

^ "Interview with Guido van Rossum". July 1998. Archived from the original on 2007-05-01. Retrieved 2007-04-29.

^ "A Shorter History of ALGOL 68". Archived from the original on 2006-08-10. Retrieved 2006-09-15.

^ Veer, Marcel van der (2023-04-05). "Revised Report on the Algorithmic Language Algol 68". jmvdveer.home.xs4all.nl/. Archived from the original on 2013-03-17.

^ Veer, Marcel van der (2023-04-05). "Revised Report on the Algorithmic Language Algol 68". jmvdveer.home.xs4all.nl/. Archived from the original on 2013-03-17.

^ Veer, Marcel van der (2023-04-05). "Revised Report on the Algorithmic Language Algol 68". jmvdveer.home.xs4all.nl/. Archived from the original on 2013-03-17.

^ Veer, Marcel van der (2023-04-05). "Revised Report on the Algorithmic Language Algol 68". jmvdveer.home.xs4all.nl/. Archived from the original on 2013-03-17.

^ "Gommas?".

^ Revised Report on the Algorithmic Language Algol 68 Archived 2013-03-17 at the Wayback Machine. jmvdveer.home.xs4all.nl (1968-12-20). Retrieved on 2013-07-21.

^ Terekhov, Andrey (2014). "ALGOL 68 and Its Impact on the USSR and Russian Programming". 2014 Third International Conference on Computer Technology in Russia and in the Former Soviet Union. pp. 97–106. doi:10.1109/SoRuCom.2014.29. ISBN 978-1-4799-1799-0. S2CID 16097093.

^ http://toc.proceedings.com/25445webtoc.pdf "Алгол 68 и его влияние на программирование в СССР и России" – pages: 336 & 342

^ Lindsey 1996.

^ a b 
Lindsey, Charles H. (1996). Bergin, T. J.; Gibson, R. G. (eds.). A history of ALGOL 68. History of Programming Languages-II. Vol. 28. also in ACM SIGPLAN Notices 28(3), March 1993 (includes a comprehensive bibliography of the meetings and discussions before, during and after development of ALGOL 68). ACM Press. pp. 97–132. doi:10.1145/155360.155365. ISBN 978-0-201-89502-5. {{cite book}}: |journal= ignored (help)

^ Programming Algol 68 Made Easy

^ Veer, Marcel van der. "Marcel van der Veer - Algol 68 Genie". jmvdveer.home.xs4all.nl/.

^ Lindsey 1993, p. 7.

^ a b c d Lindsey 1993, p. 9.

^ Lindsey 1993, p. 24.

^ a b Lindsey 1993, p. 10.

^ "The Algol Bulletin".

^ a b Lindsey 1993, p. 12.

^ Lindsey 1993, p. 13.

^ Lindsey 1993, p. 15.

^ Hoare, C. a. R. (November 1968). "Critique of ALGOL 68". ALGOL Bulletin. 29: 27–29.

^ a b Peck, J. E. L., ed. (1970), Proceedings of the IFIP working conference on ALGOL 68 Implementation, Munich: North-Holland, ISBN 0-7204-2045-8

^ a b c d Koster, C. H. A. "A Shorter History of Algol 68". Archived from the original on 2007-12-17.

^ van der Veer, Marcel. "Open source Algol 68 implementations". algol68.sourceforge.net.

^ E. Marchesi, Jose. "Algol68 frontend for GCC". jemarch.net.

^ Van Wijngaarden, A.; Mailloux, B. J.; Peck, J.; Koster, C. H. A. (1968-03-01). "Draft Report on the Algorithmic Language ALGOL 68". ALGOL Bulletin (Sup 26): 1–84. Retrieved 2023-04-07 – via Mar. 1968.

^ Sidney Marshall, "ALGOL 68 Implementation", Proceedings of the IFIP Working Conference on ALGOL 68 Implementation, Munich, July 20–24, 1970, J. E. L. Peck, editor, North Holland, pages 239–243.

^ Sidney Marshall, On the implementation of ALGOL 68, PhD Thesis, Dartmouth College, 1972.

^ Algol 68 Revised Report

^ Black, A. P.; Rayward-Smith, V. J. (1978-05-01). "Proposals for ALGOL H - A Superlanguage of ALGOL 68". ALGOL Bulletin (42): 36–49. Retrieved 2023-04-07 – via May. 1978.

^ "Algol68 S(S) published on the internet". Archived from the original on 2005-12-03. Retrieved 2004-08-30.

^ Veer, Marcel van der. "Marcel van der Veer - Algol 68 Genie". jmvdveer.home.xs4all.nl/. Retrieved 2023-04-07.

^ "Draft Report on the Algorithmic Language ALGOL 68". March 1968. Archived from the original on 2007-09-30. Retrieved 2007-06-22.

^ "Penultimate Draft Report on the Algorithmic Language ALGOL 68 – Chapters 1-9" (PDF). October 1968. Retrieved 2007-06-22.[permanent dead link]

^ "Penultimate Draft Report on the Algorithmic Language ALGOL 68 – Chapters 10-12" (PDF). October 1968. Retrieved 2007-06-22.[permanent dead link]

^ "Report on the Algorithmic Language ALGOL 68" (PDF). December 1968. Archived from the original (PDF) on 2008-04-06. Retrieved 2007-12-30.

^ "Revised Report on the Algorithmic Language Algol 68". September 1973. Archived from the original on 2007-09-27. Retrieved 2007-04-30.

^ Lu Hu-quan (1971). "The Translation of Algol 68 into Chinese" (PDF). Peking, China: Institute of Mathematics, Academia Sinica. Retrieved 2012-08-17.

^ "GOST 27974-88 Programming language ALGOL 68 – Язык программирования АЛГОЛ 68" (PDF) (in Russian). GOST. 1988. Archived from the original (PDF) on 2008-11-15. Retrieved 2008-11-15.

^ "GOST 27975-88 Programming language ALGOL 68 extended – Язык программирования АЛГОЛ 68 расширенный" (PDF) (in Russian). GOST. 1988. Archived from the original (PDF) on 2011-04-29. Retrieved 2008-11-15.

^ "Format syntax in ALGOL 68G". Archived from the original on 2008-01-09. Retrieved 2023-04-07.

^ Needham, R. M.; Wilkes, M. V. (January 1979). "The Cambridge CAP Computer and its Operating System" (PDF). Microsoft Research.

^ David Holdsworth (Winter 2009–2010). "KDF9 Time Sharing: Eldon 2 is not EGDON!". Computer Resurrection – Number 49. Computer Conservation Society. Retrieved 2010-10-03.

^ I F Currie; J M Foster (September 1982). "RSRE Memorandum" (PDF). vitanuova.com. Retrieved 2023-04-07.

^ Эльбрус Бабаяна и Pentium Пентковского. Ixbt.com. Retrieved 21 July 2013.

^ Oliver, J. R.; Newton, R. S. (1979). "Practical experience with ALGOL 68-RT". The Computer Journal. 22 (2): 114–118. doi:10.1093/comjnl/22.2.114.

^ Applications, libraries, and test suites — Software Preservation Group. Softwarepreservation.org. Retrieved 21 July 2013.

^ Revised Report, page 123, footnote

^ Lindsey, C. H. (July 1974). "Partial Parametrization". ALGOL Bulletin (37): 24–26. Retrieved 2022-09-19.

^ Lindsey, C. H.; Boom, H. J. (December 1978). "A Modules and Separate Compilation facility for ALGOL 68". ALGOL Bulletin (43): 19–53. Retrieved 2020-01-29. Comments errata

^ Lindsey, C. H. (July 1974). "Modals". ALGOL Bulletin (37): 26–29. Retrieved 2022-09-19.

^ "Archived copy" (PDF). Archived from the original (PDF) on 2010-04-15. Retrieved 2010-03-20.{{cite web}}:  CS1 maint: archived copy as title (link)

^ http://htportal.acm.org/ft_gateway.cfm?id=803425&type=pdf[permanent dead link]

^ An abstract ALGOL 68 machine and its application in a machine independent compiler – Springer. Springerlink.com. Retrieved on 2013-07-21.

^ "The Encyclopedia of Computer Languages". Archived from the original on 2011-03-10. Retrieved 2010-03-20.

^ Open source Algol 68 implementations – Browse Files at. Sourceforge.net. Retrieved on 2013-07-21.

^ [1] Archived 2006-08-29 at the Wayback Machine

^ "Archived copy" (PDF). Archived from the original (PDF) on 2014-01-02. Retrieved 2005-08-27.{{cite web}}:  CS1 maint: archived copy as title (link)

^ C. H. A. Koster (1993). The Making of Algol 68. Lecture Notes in Computer Science. CiteSeerX 10.1.1.76.2072.

^ Dijkstra, E. W. "To the Editor ALGOL 68 Mathematische Centrum". Archived from the original on 2007-04-21. Retrieved 2007-04-28.

^ van Rossum, Guido (June 2005). "Python-Dev Wishlist: dowhile". Retrieved 2007-04-28.

^ Hoare, C. A. R. (February 1981) [based on his 1980 Turing Award lecture]. "The emperor's old clothes". Communications of the ACM. 24 (2): 75–83. doi:10.1145/358549.358561. S2CID 97895. Alt URL Archived 2017-10-02 at the Wayback Machine

^ "ALGOL Bulletin (referred to in AB30.1.1.1)". March 1970. Archived from the original on 2007-09-30. Retrieved 2007-03-01.


Works cited[edit]

Brailsford, D. F. and Walker, A. N., Introductory ALGOL 68 Programming, Ellis Horwood/Wiley, 1979
Lindsey, C. H. and van der Meulen, S. G., Informal Introduction to ALGOL 68, North-Holland, 1971
Lindsey, C. H. (1993-03-02). "A History of ALGOL 68". ACM SIGPLAN Notices. 28 (3): 97–132. doi:10.1145/155360.155365.
McGettrick, A. D., ALGOL 68, A First and Second Course, Cambridge Univ. Press, 1978
Peck, J. E. L., An ALGOL 68 Companion, Univ. of British Columbia, October 1971
Tanenbaum, A. S., A Tutorial on ALGOL 68, Computing Surveys 8, 155-190, June 1976 and 9, 255-256, September 1977, [7][permanent dead link]
Woodward, P. M. and Bond, S. G., ALGOL 68-R Userssic Guide, London, Her Majesty's Stationery Office, 1972

External links[edit]
Revised Report on the Algorithmic Language ALGOL 68 The official reference for users and implementors of the language (large pdf file, scanned from Algol Bulletin)
Revised Report on the Algorithmic Language ALGOL 68 Hyperlinked HTML version of the Revised Report
A Tutorial on Algol 68, by Andrew S. Tanenbaum, in Computing Surveys, Vol. 8, No. 2, June 1976, with Corrigenda (Vol. 9, No. 3, September 1977)
Algol 68 Genie – a GNU GPL Algol 68 compiler-interpreter
Open source ALGOL 68 implementations, on SourceForge
Algol68 Standard Hardware representation (.pdf) Archived 2014-01-02 at the Wayback Machine
Из истории создания компилятора с Алгол 68
Algol 68 – 25 Years in the USSR
Система программ динамической поддержки для транслятора с Алгол 68
C history with Algol68 heritage
McJones, Paul, "Algol 68 implementations and dialects", Software Preservation Group, Computer History Museum, 2011-07-05
Web enabled ALGOL 68 compiler for small experiments
vteALGOL programmingImplementationsTechnicalstandards
ALGOL 58
ALGOL 60
ALGOL 68
Dialects
ABC ALGOL
ALCOR
ALGO
ALGOL 68C
ALGOL 68-R
ALGOL 68RS (ELLA)
ALGOL 68S
ALGOL N
ALGOL W
ALGOL X
Atlas Autocode (Edinburgh IMP)
Burroughs ALGOL
CORAL 66
Dartmouth ALGOL 30
DASK ALGOL
DG/L
Elliott ALGOL
Executive Systems Problem Oriented Language (ESPOL) → New Executive Programming Language (NEWP)
FLACC
IMP
JOVIAL
Kidsgrove Algol
MAD
Mary
NELIAC
RTL/2
S-algol, PS-algol, Napier88
Simula
Small Machine ALGOL Like Language (SMALL)
SMIL ALGOL
Formalisms
Jensen's device
Van Wijngaarden grammar
CommunityOrganizationsProfessionalassociations
ALCOR Group
Association for Computing Machinery (ACM)
BSI Group
Euro-Asian Council for Standardization, Metrology and Certification (EASC)
International Federation for Information Processing (IFIP) IFIP Working Group 2.1
Society of Applied Mathematics and Mechanics (GAMM)
Business
Burroughs Corporation
Elliott Brothers
Regnecentralen
Education
Case Institute of Technology
University of Edinburgh
University of St Andrews
Manchester University
Massachusetts Institute of Technology (MIT)
Government
Royal Radar Establishment (RRE)
PeopleALGOL 58
John Backus
Friedrich L. Bauer
Hermann Bottenbruch
Charles Katz
Alan Perlis
Heinz Rutishauser
Klaus Samelson
Joseph Henry Wegstein
MAD
Bruce Arden
Bernard Galler
Robert M. Graham
ALGOL 60
Backus^
Roland Carl Backhouse
Bauer^
Richard Bird
Stephen R. Bourne
Edsger W. Dijkstra
Andrey Ershov
Robert W. Floyd
Jeremy Gibbons
Julien Green
David Gries
Eric Hehner
Tony Hoare
Jørn Jensen
Katz^
Peter Landin
Tom Maibaum
Conor McBride
John McCarthy
Carroll Morgan
Peter Naur
Maurice Nivat
John E. L. Peck
Perlis^
Brian Randell
Rutishauser^
Samelson^
Jacob T. Schwartz
Micha Sharir
David Turner
Bernard Vauquois
Eiiti Wada
Wegstein^
Adriaan van Wijngaarden
Mike Woodger
Simula
Ole-Johan Dahl
Kristen Nygaard
ALGOL 68
Bauer^
Susan G. Bond
Bourne^
Robert Dewar
Dijkstra^
Gerhard Goos
Michael Guy
Hoare^
Cornelis H. A. Koster
Peter Landin
Charles H. Lindsey
Barry J. Mailloux
McCarthy^
Lambert Meertens
Naur^
Peck^
Willem van der Poel
Randell^
Douglas T. Ross
Samelson^
Michel Sintzoff
van Wijngaarden^
Niklaus Wirth
Woodger^
Philip Woodward
Nobuo Yoneda

Hal Abelson
John Barnes
Tony Brooker
Ron Morrison
Peter O'Hearn
John C. Reynolds
ALGOL BulletinComparison
ALGOL 58 influence on ALGOL 60
ALGOL 68 to other languages
ALGOL 68 to C++

^ = full name and link in prior ALGOL version above Category: ALGOL  Category: ALGOL 60

Authority control databases: National 
Germany





Retrieved from "https://en.wikipedia.org/w/index.php?title=ALGOL_68&oldid=1207178973"
Categories: ALGOL 68Algol programming language familyAcademic programming languagesComputer-related introductions in 1968Procedural programming languagesProgramming languages created in 1968Systems programming languagesProgramming languagesHidden categories: Webarchive template wayback linksCS1 errors: periodical ignoredAll articles with dead external linksArticles with dead external links from November 2016Articles with permanently dead external linksCS1 Russian-language sources (ru)CS1 maint: archived copy as titleArticles with dead external links from October 2016Articles with short descriptionShort description matches WikidataUse dmy dates from May 2019All articles with unsourced statementsArticles with unsourced statements from August 2011Articles with dead external links from June 2017Articles with GND identifiersArticles with example ALGOL 68 code






 This page was last edited on 14 February 2024, at 05:15 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License 4.0;
additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view













Toggle limited content width







